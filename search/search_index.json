{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"DSA/DP/01-nth-fibonacci-nummber/","title":"1. Nth Fibonacci Nummber","text":""},{"location":"DSA/DP/01-nth-fibonacci-nummber/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/01-nth-fibonacci-nummber/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nint f(int n, vector&lt;int&gt; &amp;dp) {\n    if (n &lt;= 1) return 1;\n\n    if (dp[n] != -1) return dp[n];\n\n    return dp[n] = f(n-1, dp) + f(n-2, dp);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; dp(n + 1, -1);\n    cout &lt;&lt; f(n, dp);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code> rec stack space + dp array</li> </ul>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; dp(n + 1, -1);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i=2; i&lt;=n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n\n    cout &lt;&lt; dp[n];\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    int prev2 = 0, prev = 1;\n    int curr;\n\n    if (n &lt;= 1) {\n        cout &lt;&lt; n;\n        return;\n    }\n\n    for (int i=2; i&lt;=n; i++) {\n        curr = prev + prev2;\n        prev2 = prev;\n        prev = curr;\n    }\n\n    cout &lt;&lt; curr;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/01-nth-fibonacci-nummber/#tags","title":"Tags","text":"<ul> <li><code>#recursion #dp #fibonacci</code></li> </ul>"},{"location":"DSA/DP/02-count-ways-to-reach-nth-stair/","title":"2. Count Ways To Reach Nth Stair","text":""},{"location":"DSA/DP/02-count-ways-to-reach-nth-stair/#description","title":"Description","text":"<ul> <li>Count no. of ways to reach nth stair from 0th stair by jumping 1 or 2 stairs at a time.</li> <li>Solution same as 1st question.</li> </ul>"},{"location":"DSA/DP/02-count-ways-to-reach-nth-stair/#tags","title":"Tags","text":"<ul> <li><code>#recursion #dp #fibonacci</code></li> </ul>"},{"location":"DSA/DP/03-frog-jump/","title":"3. Frog Jump","text":""},{"location":"DSA/DP/03-frog-jump/#description","title":"Description","text":"<ul> <li>Frog can jump from one building to other with the energy of abs(heights[i] - heights[j]).</li> <li>Frog can jump 1 or 2 buildings at a time.</li> <li>Find minimum energy to go from 1st to Nth building.</li> </ul>"},{"location":"DSA/DP/03-frog-jump/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/03-frog-jump/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, vector&lt;int&gt; &amp;heights, vector&lt;int&gt; &amp;dp) {\n    if (ind == 0) return 0;\n\n    if (dp[ind] != -1) return dp[ind];\n\n    int left = solve(ind - 1, heights, dp) + abs(heights[ind] - heights[ind - 1]);\n\n    int right = INT_MAX;\n    if (ind &gt; 1) right = solve(ind - 2, heights, dp) + abs(heights[ind] - heights[ind - 2]);\n\n    return dp[ind] = min(left, right);\n}\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n, -1);\n    return solve(n - 1, heights, dp);\n}\n</code></pre>"},{"location":"DSA/DP/03-frog-jump/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/03-frog-jump/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n);\n    dp[0] = 0;\n\n    for (int i=1; i&lt;n; i++) {\n        int fs = dp[i-1] + abs(heights[i] - heights[i-1]);\n        int ss = INT_MAX;\n        if (i &gt; 1) ss = dp[i-2] + abs(heights[i] - heights[i - 2]);\n\n        dp[i] = min(fs, ss);\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/03-frog-jump/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/03-frog-jump/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    int prev2 = 0, prev = 0;\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int fs = prev + abs(heights[i] - heights[i-1]);\n        int ss = INT_MAX;\n        if (i &gt; 1) ss = prev2 + abs(heights[i] - heights[i - 2]);\n\n        curr = min(fs, ss);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return curr;\n}\n</code></pre>"},{"location":"DSA/DP/03-frog-jump/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/03-frog-jump/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/frog-jump_3621012</li> </ul>"},{"location":"DSA/DP/03-frog-jump/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion</code></li> </ul>"},{"location":"DSA/DP/04-frog-jump-k-jumps/","title":"4. Frog Jump (k Jumps)","text":""},{"location":"DSA/DP/04-frog-jump-k-jumps/#description","title":"Description","text":"<ul> <li>Here, k jumps are allowed.</li> </ul>"},{"location":"DSA/DP/04-frog-jump-k-jumps/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, int k, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n, INT_MAX);\n    dp[0] = 0;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=1; j&lt;=k; j++) {\n            if (i-j &gt;= 0) {\n                dp[i] = min(dp[i], dp[i-j] + abs(heights[i] - heights[i-j]));\n            } else {\n                break;\n            }\n        }\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/04-frog-jump-k-jumps/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/04-frog-jump-k-jumps/#tags","title":"Tags","text":"<ul> <li><code>#recursion #dp</code></li> </ul>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/","title":"5. Maximum Sum Of Non-adjacent Elements","text":""},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;dp) {\n    if (ind == 0) return nums[ind];\n\n    if (ind &lt; 0) return 0;\n\n    if (dp[ind] != -1) return dp[ind];\n\n    int pick = nums[ind] + solve(ind - 2, nums, dp);\n    int notPick = solve(ind - 1, nums, dp);\n\n    return dp[ind] = max(pick, notPick);\n}\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    vector&lt;int&gt; dp(n, -1);\n\n    return solve(n-1, nums, dp);\n}\n</code></pre>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    vector&lt;int&gt; dp(n);\n    dp[0] = nums[0];\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += dp[i-2];\n\n        int notTake = dp[i-1];\n\n        dp[i] = max(take, notTake);\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    int prev2 = 0, prev = nums[0];\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += prev2;\n\n        int notTake = prev;\n\n        curr = max(take, notTake);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return prev;\n}\n</code></pre>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/maximum-sum-of-non-adjacent-elements_843261</li> </ul>"},{"location":"DSA/DP/05-maximum-sum-of-non-adjacent-elements/#tags","title":"Tags","text":"<ul> <li><code>#recursion #dp #sum #maximization #take-not-take</code></li> </ul>"},{"location":"DSA/DP/06-house-robber-2/","title":"6. House Robber 2","text":""},{"location":"DSA/DP/06-house-robber-2/#description","title":"Description","text":"<ul> <li>Same as 5th question but a circular array</li> </ul>"},{"location":"DSA/DP/06-house-robber-2/#solution","title":"Solution","text":""},{"location":"DSA/DP/06-house-robber-2/#space-optimization","title":"Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    int prev2 = 0, prev = nums[0];\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += prev2;\n\n        int notTake = prev;\n\n        curr = max(take, notTake);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return prev;\n}\n\nlong long int houseRobber(vector&lt;int&gt;&amp; valueInHouse)\n{\n    int n = valueInHouse.size();\n    vector&lt;int&gt; temp1, temp2;\n\n    if (n == 1) return valueInHouse[0];\n\n    for (int i=0; i&lt;n; i++) {\n        if (i != 0) temp1.push_back(valueInHouse[i]);\n        if (i != n-1) temp2.push_back(valueInHouse[i]);\n    }\n\n    return max(maximumNonAdjacentSum(temp1), maximumNonAdjacentSum(temp2));\n}\n</code></pre>"},{"location":"DSA/DP/06-house-robber-2/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/06-house-robber-2/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/house-robber_839733</li> </ul>"},{"location":"DSA/DP/06-house-robber-2/#tags","title":"Tags","text":"<ul> <li><code>#recursion #dp #sum #circular-array #take-not-take</code></li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/","title":"7. Ninja's Training","text":""},{"location":"DSA/DP/07-ninja-s-training/#description","title":"Description","text":"<ul> <li>There is a N x 3 array of points.</li> <li>The ninja cannot earn points from the index which was taken in previous step.</li> <li>Find max points which ninja can earn.</li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/07-ninja-s-training/#1-memorization","title":"1) Memorization","text":"<pre><code>int solve(int day, int last, vector&lt;vector&lt;int&gt;&gt; &amp;points, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (day == 0) {\n        int maxi = 0;\n        for (int task = 0; task &lt; 3; task++) {\n            if (task != last) {\n                maxi = max(maxi, points[0][task]);\n            }\n        }\n\n        return maxi;\n    }\n\n    if (dp[day][last] != -1) return dp[day][last];\n\n    int maxi = 0;\n\n    for (int task = 0; task &lt; 3; task++) {\n        if (task != last) {\n            maxi = max(maxi, points[day][task] + solve(day - 1, task, points, dp));\n        }\n    }\n\n    return dp[day][last] = maxi;\n}\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (4, -1));\n\n    return solve(n - 1, 3, points, dp);\n}\n</code></pre>"},{"location":"DSA/DP/07-ninja-s-training/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(n) + O(n * 4)</code></li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (4, 0));\n\n    dp[0][0] = max(points[0][1], points[0][2]);\n    dp[0][1] = max(points[0][0], points[0][2]);\n    dp[0][2] = max(points[0][0], points[0][1]);\n    dp[0][3] = max({points[0][0], points[0][1], points[0][2]});\n\n    for (int day = 1; day &lt; n; day++) {\n        for (int last = 0; last &lt; 4; last++) {\n            for (int task = 0; task &lt; 3; task++) {\n                if (task != last) {\n                    int point = points[day][task] + dp[day - 1][task];\n                    dp[day][last] = max(dp[day][last], point);\n                }\n            }\n        }\n    }\n\n    return dp[n-1][3];\n}\n</code></pre>"},{"location":"DSA/DP/07-ninja-s-training/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(n * 4)</code></li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;int&gt; prev(4, 0);\n\n    prev[0] = max(points[0][1], points[0][2]);\n    prev[1] = max(points[0][0], points[0][2]);\n    prev[2] = max(points[0][0], points[0][1]);\n    prev[3] = max({points[0][0], points[0][1], points[0][2]});\n\n    for (int day = 1; day &lt; n; day++) {\n        vector&lt;int&gt; temp(4, 0);\n\n        for (int last = 0; last &lt; 4; last++) {\n            for (int task = 0; task &lt; 3; task++) {\n                if (task != last) {\n                    int point = points[day][task] + prev[task];\n                    temp[last] = max(temp[last], point);\n                }\n            }\n        }\n\n        prev = temp;\n    }\n\n    return prev[3];\n}\n</code></pre>"},{"location":"DSA/DP/07-ninja-s-training/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(4)</code></li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ninja-s-training_3621003</li> </ul>"},{"location":"DSA/DP/07-ninja-s-training/#tags","title":"Tags","text":"<ul> <li><code>#recursion #sum #dp #maximization</code></li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/","title":"8. Grid Unique Paths","text":""},{"location":"DSA/DP/08-grid-unique-paths/#description","title":"Description","text":"<ul> <li>Count all unique paths on m x n grid by going only down and right.</li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/08-grid-unique-paths/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 &amp;&amp; j == 0) return 1;\n\n    if (i &lt; 0 || j &lt; 0) return 0;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = solve(i-1, j, dp);\n    int left = solve(i, j-1, dp);\n\n    return dp[i][j] = up + left;\n} \n\nint uniquePaths(int m, int n) {\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n, -1));\n\n    return solve(m-1, n-1, dp);\n}\n</code></pre>"},{"location":"DSA/DP/08-grid-unique-paths/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)</code></li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n, 0));\n    dp[0][0] = 1;\n\n    for (int i=0; i&lt;m; i++) {\n        for (int j=0; j&lt;n; j++) {\n            if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = dp[i-1][j];\n                if (j &gt; 0) left = dp[i][j-1];\n                dp[i][j] = up + left;\n            }\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n</code></pre>"},{"location":"DSA/DP/08-grid-unique-paths/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    vector&lt;int&gt; prev_row(n);\n    prev_row[0] = 1;\n\n    for (int i=0; i&lt;m; i++) {\n        vector&lt;int&gt; row(n);\n        for (int j=0; j&lt;n; j++) {\n            if (i == 0 &amp;&amp; j == 0) row[j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = prev_row[j];\n                if (j &gt; 0) left = row[j-1];\n                row[j] = up + left;\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/08-grid-unique-paths/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#notes","title":"Notes","text":"<ul> <li>Answer is (m + n - 2) C (m - 1).</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    int N = m + n - 2;\n    int r = m - 1;\n    double res = 1;\n\n    for (int i=1; i&lt;=r; i++) {\n        res = (res * (N - r + i)) / i;\n    }\n\n    return int(res);\n}\n</code></pre>"},{"location":"DSA/DP/08-grid-unique-paths/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/total-unique-paths_1081470</li> </ul>"},{"location":"DSA/DP/08-grid-unique-paths/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #count #grid</code></li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/","title":"9. Grid Unique Paths 2","text":""},{"location":"DSA/DP/09-grid-unique-paths-2/#description","title":"Description","text":"<ul> <li>Here there will be dead cells (-1).</li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/09-grid-unique-paths-2/#1-memorization","title":"1) Memorization","text":"<pre><code>int mod = 1e9 + 7;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;dp, vector&lt;vector&lt;int&gt;&gt; &amp;mat) {\n    if (i == 0 &amp;&amp; j == 0) return 1;\n\n    if (i &lt; 0 || j &lt; 0) return 0;\n\n    if (mat[i][j] == -1) return 0;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = solve(i-1, j, dp, mat);\n    int left = solve(i, j-1, dp, mat);\n\n    return dp[i][j] = (up + left) % mod;\n} \n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    return solve(n-1, m-1, dp, mat);\n}\n</code></pre>"},{"location":"DSA/DP/09-grid-unique-paths-2/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)</code></li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int mod = 1e9 + 7;\n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n    dp[0][0] = 1;\n\n    for (int i=0; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            if (mat[i][j] == -1) dp[i][j] = 0;\n            else if(i == 0 &amp;&amp; j == 0) dp[i][j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = dp[i-1][j];\n                if (j &gt; 0) left = dp[i][j-1];\n                dp[i][j] = (up + left) % mod;\n            }\n        }\n    }\n\n    return dp[n-1][m-1];\n}\n</code></pre>"},{"location":"DSA/DP/09-grid-unique-paths-2/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int mod = 1e9 + 7;\n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;int&gt; prev_row(n);\n    prev_row[0] = 1;\n\n    for (int i=0; i&lt;n; i++) {\n        vector&lt;int&gt; row(m);\n        for (int j=0; j&lt;m; j++) {\n            if (mat[i][j] == -1) row[j] = 0;\n            else if(i == 0 &amp;&amp; j == 0) row[j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = prev_row[j];\n                if (j &gt; 0) left = row[j-1];\n                row[j] = (up + left) % mod;\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[m-1];\n}\n</code></pre>"},{"location":"DSA/DP/09-grid-unique-paths-2/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/unique-paths-ii_977241</li> </ul>"},{"location":"DSA/DP/09-grid-unique-paths-2/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #count #grid</code></li> </ul>"},{"location":"DSA/DP/10-grid-minimum-path-sum/","title":"10. Grid Minimum Path Sum","text":""},{"location":"DSA/DP/10-grid-minimum-path-sum/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/10-grid-minimum-path-sum/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 &amp;&amp; j == 0) return grid[i][j];\n\n    if (i &lt; 0 || j &lt; 0) return 1e9;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = grid[i][j] + solve(i-1, j, grid, dp);\n    int left = grid[i][j] + solve(i, j-1, grid, dp);\n\n    return dp[i][j] = min(up, left);\n}\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    return solve(n-1, m-1, grid, dp);\n}\n</code></pre>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: `O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)``</li> </ul>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n    dp[0][0] = grid[0][0];\n\n    for (int i=0; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            if (i == 0 &amp;&amp; j == 0) continue;\n            else {\n                int up = 1e9, left = 1e9;\n                if (i &gt; 0) up = grid[i][j] + dp[i-1][j];\n                if (j &gt; 0) left = grid[i][j] + dp[i][j-1];\n\n                dp[i][j] = min(up, left);\n            }\n        }\n    }\n\n    return dp[n-1][m-1];\n}\n</code></pre>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n\n    vector&lt;int&gt; prev_row(m, 0);\n\n    for (int i=0; i&lt;n; i++) {\n        vector&lt;int&gt; row(m, 0);\n        for (int j=0; j&lt;m; j++) {\n            if (i == 0 &amp;&amp; j == 0) row[0] = grid[i][j];\n            else {\n                int up = 1e9, left = 1e9;\n                if (i &gt; 0) up = grid[i][j] + prev_row[j];\n                if (j &gt; 0) left = grid[i][j] + row[j-1];\n\n                row[j] = min(up, left);\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[m-1];\n}\n</code></pre>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-path-sum_985349</li> </ul>"},{"location":"DSA/DP/10-grid-minimum-path-sum/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #grid</code></li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/","title":"11. Triangle - Fixed Starting Point And Variable Ending Point","text":""},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#description","title":"Description","text":"<ul> <li>Minimize path sum by going only down or right diagonal.</li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, int &amp;n, vector&lt;vector&lt;int&gt;&gt; &amp;triangle, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == n-1) return triangle[i][j];\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int down = triangle[i][j] + solve(i+1, j, n, triangle, dp);\n    int diagonal = triangle[i][j] + solve(i+1, j+1, n, triangle, dp);\n\n    return dp[i][j] = min(down, diagonal);\n}\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n, -1));\n    return solve(0, 0, n, triangle, dp);\n}\n</code></pre>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n) + O(n * n)</code></li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n, 0));\n\n    // base case\n    for (int j=0; j&lt;n; j++) {\n        dp[n-1][j] = triangle[n-1][j];\n    }\n\n    for (int i=n-2; i&gt;=0; i--) {\n        for (int j=i; j&gt;=0; j--) {\n            int down = triangle[i][j] + dp[i+1][j];\n            int diagonal = triangle[i][j] + dp[i+1][j+1];\n\n            dp[i][j] = min(down, diagonal);\n        }\n    }\n\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n)</code></li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;int&gt; prev_row(n, 0);\n\n    // base case\n    for (int j=0; j&lt;n; j++) {\n        prev_row[j] = triangle[n-1][j];\n    }\n\n    for (int i=n-2; i&gt;=0; i--) {\n        vector&lt;int&gt; row(n, 0);\n        for (int j=i; j&gt;=0; j--) {\n            int down = triangle[i][j] + prev_row[j];\n            int diagonal = triangle[i][j] + prev_row[j+1];\n\n            row[j] = min(down, diagonal);\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[0];\n}\n</code></pre>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/triangle_1229398</li> </ul>"},{"location":"DSA/DP/11-triangle-fixed-starting-point-and-variable-ending-point/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #minimization #grid</code></li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/","title":"12. Maximum Falling Path Sum","text":""},{"location":"DSA/DP/12-maximum-falling-path-sum/#description","title":"Description","text":"<ul> <li>Start from any cell in first row and reach any cell in last row to maximize sum.</li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/12-maximum-falling-path-sum/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint n, m;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (j &gt;= m || j &lt; 0) return -1e6;\n\n    if (i == 0) return matrix[i][j];\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int u = matrix[i][j] + solve(i-1, j, matrix, dp);\n    int ld = matrix[i][j] + solve(i-1, j-1, matrix, dp);\n    int rd = matrix[i][j] + solve(i-1, j+1, matrix, dp);\n\n    return dp[i][j] = max({u, ld, rd});\n}\n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    n = matrix.size();\n    m = matrix[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, solve(n-1, j, matrix, dp));\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n)</code></li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n\n    // base case\n    for (int j=0; j&lt;m; j++) {\n        dp[0][j] = matrix[0][j];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            int u = -1e6, ld = -1e6, rd = -1e6;\n\n            u = matrix[i][j] + dp[i-1][j];\n            if (j-1 &gt;= 0) ld = matrix[i][j] + dp[i-1][j-1];\n            if (j+1 &lt; m) rd = matrix[i][j] + dp[i-1][j+1];\n\n            dp[i][j] = max({u, ld, rd});\n        }\n    }\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, dp[n-1][j]);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#notes","title":"Notes","text":""},{"location":"DSA/DP/12-maximum-falling-path-sum/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector&lt;int&gt; prev(m, 0), curr(m, 0);\n\n    // base case\n    for (int j=0; j&lt;m; j++) {\n        prev[j] = matrix[0][j];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            int u = -1e6, ld = -1e6, rd = -1e6;\n\n            u = matrix[i][j] + prev[j];\n            if (j-1 &gt;= 0) ld = matrix[i][j] + prev[j-1];\n            if (j+1 &lt; m) rd = matrix[i][j] + prev[j+1];\n\n            curr[j] = max({u, ld, rd});\n        }\n\n        prev = curr;\n    }\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, prev[j]);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/maximum-path-sum-in-the-matrix_797998</li> </ul>"},{"location":"DSA/DP/12-maximum-falling-path-sum/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #maximization #grid</code></li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/","title":"13. 3d Dp - Grid","text":""},{"location":"DSA/DP/13-3d-dp-grid/#description","title":"Description","text":"<ul> <li>Alice starts from (0,0) and bob starts from (0, c-1)</li> <li>Both can go down or diagonally down.</li> <li>Maximize sum (if both go in same cell, count only once)</li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/13-3d-dp-grid/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int i, int j1, int j2, int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; &amp;dp) {\n\n    // base cases\n    if (j1 &lt; 0 || j1 &gt;= c || j2 &lt; 0 || j2 &gt;= c) return -1e9;\n\n    if (i == r-1) {\n        if (j1 == j2) return grid[i][j1];\n        else return grid[i][j1] + grid[i][j2];\n    }\n\n    if (dp[i][j1][j2] != -1) return dp[i][j1][j2];\n\n    // explore all paths of alice and bob simultaneously\n\n    int maxi = 0;\n\n    for (int d1 = -1; d1 &lt;= 1; d1++) {\n        for (int d2 = -1; d2 &lt;= 1; d2++) {\n            int value = 0;\n\n            if (j1 == j2) value += grid[i][j1];\n            else value += grid[i][j1] + grid[i][j2];\n\n            value += solve(i+1, j1+d1, j2+d2, r, c, grid, dp);\n\n            maxi = max(maxi, value);\n        }\n    }\n\n    return dp[i][j1][j2] = maxi;\n}\n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(r, vector&lt;vector&lt;int&gt;&gt; (c, vector&lt;int&gt; (c, -1)));\n    return solve(0, 0, c-1, r, c, grid, dp);\n}\n</code></pre>"},{"location":"DSA/DP/13-3d-dp-grid/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(r * c * c) + O(r)</code></li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(r, vector&lt;vector&lt;int&gt;&gt; (c, vector&lt;int&gt; (c, 0)));\n\n    // base case\n    for (int j1 = 0; j1 &lt; c; j1++) {\n        for (int j2 = 0; j2 &lt; c; j2++) {\n            if (j1 == j2) dp[r-1][j1][j2] = grid[r-1][j1];\n            else dp[r-1][j1][j2] = grid[r-1][j1] + grid[r-1][j2];\n        }\n    }\n\n    for (int i=r-2; i&gt;=0; i--) {\n        for (int j1=0; j1&lt;c; j1++) {\n            for (int j2=0; j2&lt;c; j2++) {\n                int maxi = 0;\n\n                for (int d1 = -1; d1 &lt;= 1; d1++) {\n                    for (int d2 = -1; d2 &lt;= 1; d2++) {\n                        int value = 0;\n\n                        if (j1 == j2) value += grid[i][j1];\n                        else value += grid[i][j1] + grid[i][j2];\n\n                        if (j1+d1 &gt;= 0 &amp;&amp; j1+d1 &lt; c &amp;&amp; j2+d2 &gt;= 0 &amp;&amp; j2+d2 &lt; c)\n                            value += dp[i+1][j1+d1][j2+d2];\n                        else \n                            value += -1e9;\n\n                        maxi = max(maxi, value);\n                    }\n                } \n\n                dp[i][j1][j2] = maxi;\n            }\n        }\n    }\n\n    return dp[0][0][c-1];\n}\n</code></pre>"},{"location":"DSA/DP/13-3d-dp-grid/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(r * c * c)</code></li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;int&gt;&gt; prev(c, vector&lt;int&gt; (c, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(c, vector&lt;int&gt; (c, 0));\n\n    // base case\n    for (int j1 = 0; j1 &lt; c; j1++) {\n        for (int j2 = 0; j2 &lt; c; j2++) {\n            if (j1 == j2) prev[j1][j2] = grid[r-1][j1];\n            else prev[j1][j2] = grid[r-1][j1] + grid[r-1][j2];\n        }\n    }\n\n    for (int i=r-2; i&gt;=0; i--) {\n        for (int j1=0; j1&lt;c; j1++) {\n            for (int j2=0; j2&lt;c; j2++) {\n                int maxi = 0;\n\n                for (int d1 = -1; d1 &lt;= 1; d1++) {\n                    for (int d2 = -1; d2 &lt;= 1; d2++) {\n                        int value = 0;\n\n                        if (j1 == j2) value += grid[i][j1];\n                        else value += grid[i][j1] + grid[i][j2];\n\n                        if (j1+d1 &gt;= 0 &amp;&amp; j1+d1 &lt; c &amp;&amp; j2+d2 &gt;= 0 &amp;&amp; j2+d2 &lt; c)\n                            value += prev[j1+d1][j2+d2];\n                        else \n                            value += -1e9;\n\n                        maxi = max(maxi, value);\n                    }\n                } \n\n                curr[j1][j2] = maxi;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[0][c-1];\n}\n</code></pre>"},{"location":"DSA/DP/13-3d-dp-grid/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(c * c)</code></li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ninja-and-his-friends_3125885</li> </ul>"},{"location":"DSA/DP/13-3d-dp-grid/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #maximization #grid #3d-dp</code></li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/","title":"14. Subset Sum Equal To K","text":""},{"location":"DSA/DP/14-subset-sum-equal-to-k/#description","title":"Description","text":"<ul> <li>Check if any subset sums to K or not.</li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/14-subset-sum-equal-to-k/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool solve(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (target == 0) return true;\n\n    if (ind == 0) return arr[0] == target;\n\n    if (dp[ind][target] != -1) return dp[ind][target];\n\n    bool notTake = solve(ind - 1, target, arr, dp);\n    bool take = false;\n\n    if (target &gt;= arr[ind])\n        take = solve(ind - 1, target - arr[ind], arr, dp);\n\n    return dp[ind][target] = take | notTake;\n}\n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, -1));\n\n    return solve(n-1, k, arr, dp);   \n}\n</code></pre>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt; (k+1, 0));\n\n    // base cases\n    for (int i=0; i&lt;n; i++) dp[i][0] = true;\n    if (arr[0] &lt;= k) dp[0][arr[0]] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = dp[i-1][target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = dp[i-1][target-arr[i]];\n\n            dp[i][target] = take | notTake;\n        }\n    }\n\n    return dp[n-1][k];\n}\n</code></pre>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n</code></pre>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/subset-sum-equal-to-k_1550954</li> </ul>"},{"location":"DSA/DP/14-subset-sum-equal-to-k/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #subsequence #subset #subset-sum</code></li> </ul>"},{"location":"DSA/DP/15-partition-equal-subset-sum/","title":"15. Partition Equal Subset Sum","text":""},{"location":"DSA/DP/15-partition-equal-subset-sum/#description","title":"Description","text":"<ul> <li>Use 14th question logic.</li> </ul>"},{"location":"DSA/DP/15-partition-equal-subset-sum/#space-optimization","title":"Space Optimization","text":"<pre><code>bool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n\nbool canPartition(vector&lt;int&gt; &amp;arr, int n) {\n    int sum = 0;\n\n    for (int i=0; i&lt;n; i++) sum += arr[i];\n\n    if (sum % 2) return false;\n\n    int target = sum / 2;\n\n    return subsetSumToK(n, target, arr);\n}\n</code></pre>"},{"location":"DSA/DP/15-partition-equal-subset-sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/15-partition-equal-subset-sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partition-equal-subset-sum-_892980</li> </ul>"},{"location":"DSA/DP/15-partition-equal-subset-sum/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #equal #subsequence #subset #subset-sum</code></li> </ul>"},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/","title":"16. Partition A Set Into Two Subsets With Minimum Absolute Sum Difference","text":""},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/#description","title":"Description","text":"<ul> <li>Use 14th question approach.</li> </ul>"},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/#space-optimization","title":"Space Optimization","text":"<pre><code>int minSubsetSumDifference(vector&lt;int&gt;&amp; arr, int n) {\n\n    int totSum = 0;\n\n    for (int i=0; i&lt;n; i++) totSum += arr[i];\n\n    int k = totSum / 2;\n\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    int miniDiff = 1e9;\n\n    for (int i=0; i&lt;=k; i++) {\n        if (prev[i] == true) {\n            int absDiff = abs(i - (totSum - i));\n            miniDiff = min(miniDiff, absDiff);\n        }\n    }\n\n    return miniDiff;\n}\n</code></pre>"},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum_842494</li> </ul>"},{"location":"DSA/DP/16-partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #subset-sum #sum #subset #subsequence #minimization</code></li> </ul>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/","title":"17. Count Subsets With Sum K","text":""},{"location":"DSA/DP/17-count-subsets-with-sum-k/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/17-count-subsets-with-sum-k/#1-memorization","title":"1) Memorization","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint solve(int ind, int sum, vector&lt;int&gt; &amp;arr, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n\n    if (ind == 0) {\n        if (sum == 0) {\n            if (arr[0] == 0) return 2;\n            return 1;\n        }\n\n        return (arr[0] == sum);\n    }\n\n    if (dp[ind][sum] != -1) return dp[ind][sum];\n\n    int notPick = solve(ind-1, sum, arr, dp);\n    int pick = 0;\n    if (arr[ind] &lt;= sum) \n        pick = solve(ind-1, sum-arr[ind], arr, dp);\n\n    return dp[ind][sum] = (pick + notPick) % mod;\n}\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, -1));\n\n    return solve(n-1, k, arr, dp);\n}\n</code></pre>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: <code>O(n * k) + O(n)</code></li> </ul>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, 0));\n\n    if (arr[0] == 0) dp[0][0] = 2;\n    else dp[0][0] = 1;\n\n    if (arr[0] != 0 &amp;&amp; arr[0] &lt;= k) dp[0][arr[0]] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum = 0; sum &lt;= k; sum++) {\n            int notPick = dp[i-1][sum];\n            int pick = 0;\n            if (arr[i] &lt;= sum) \n                pick = dp[i-1][sum-arr[i]];\n\n            dp[i][sum] = (pick + notPick) % mod;\n        }\n    }\n\n    return dp[n-1][k];\n}\n</code></pre>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: `O(n * k)</li> </ul>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, 0));\n    vector&lt;int&gt; prev(k+1, 0), curr(k+1, 0);\n\n    if (arr[0] == 0) prev[0] = 2;\n    else prev[0] = 1;\n\n    if (arr[0] != 0 &amp;&amp; arr[0] &lt;= k) prev[arr[0]] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum = 0; sum &lt;= k; sum++) {\n            int notPick = prev[sum];\n            int pick = 0;\n            if (arr[i] &lt;= sum) \n                pick = prev[sum-arr[i]];\n\n            curr[sum] = (pick + notPick) % mod;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n</code></pre>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/number-of-subsets_3952532</li> </ul>"},{"location":"DSA/DP/17-count-subsets-with-sum-k/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #count #subset #subset-sum #subsequence</code></li> </ul>"},{"location":"DSA/DP/18-count-partitions-with-given-difference/","title":"18. Count Partitions With Given Difference","text":""},{"location":"DSA/DP/18-count-partitions-with-given-difference/#description","title":"Description","text":"<ul> <li>S1 - S2 = D and S1 &gt;= S2</li> <li>Therefore, totSum - 2*S2 = D =&gt; S2 = (totSum - D) / 2</li> </ul>"},{"location":"DSA/DP/18-count-partitions-with-given-difference/#space-optimization","title":"Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint mod = (int)(1e9 + 7);\n\nint findWays(vector&lt;int&gt; &amp;arr, int tar) {\n    int n = arr.size();\n\n    vector&lt;int&gt; prev(tar + 1, 0), curr(tar + 1, 0);\n\n    if (arr[0] &lt;= tar) prev[arr[0]] = 1;\n\n    if (arr[0] == 0) prev[0] = 2;\n    else prev[0] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum=0; sum&lt;=tar; sum++) {\n            int notTake = prev[sum];\n            int take = 0;\n            if (arr[i] &lt;= sum) take = prev[sum-arr[i]];\n\n            curr[sum] = (take + notTake) % mod;\n        }\n\n        prev = curr;\n    }\n\n    return prev[tar];\n}\n\nint countPartitions(int n, int d, vector&lt;int&gt; &amp;arr) {\n    int totSum = 0;\n\n    for (int i=0; i&lt;n; i++) totSum += arr[i];\n\n    if ((totSum - d) % 2 || (totSum - d) &lt; 0) return 0;\n\n    int tar = (totSum - d) / 2;\n\n    return findWays(arr, tar);\n}\n</code></pre>"},{"location":"DSA/DP/18-count-partitions-with-given-difference/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * tar)</code></li> <li>Space Complexity: <code>O(tar)</code></li> </ul>"},{"location":"DSA/DP/18-count-partitions-with-given-difference/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partitions-with-given-difference_3751628</li> </ul>"},{"location":"DSA/DP/18-count-partitions-with-given-difference/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #subset-sum #subsequence</code></li> </ul>"},{"location":"DSA/DP/19-0-1-knapsack/","title":"19. 0 1 Knapsack","text":""},{"location":"DSA/DP/19-0-1-knapsack/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/19-0-1-knapsack/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int ind, int wt, vector&lt;int&gt; &amp;weight, vector&lt;int&gt; &amp;value, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        if (weight[0] &lt;= wt) return value[0];\n        return 0;\n    }\n\n    if (dp[ind][wt] != -1) return dp[ind][wt];\n\n    int notTake = solve(ind-1, wt, weight, value, dp);\n    int take = 0;\n    if (weight[ind] &lt;= wt) take = value[ind] + solve(ind-1, wt-weight[ind], weight, value, dp);\n\n    return dp[ind][wt] = max(take, notTake);\n}\n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (maxWeight+1, -1));\n\n    return solve(n-1, maxWeight, weight, value, dp);\n}\n</code></pre>"},{"location":"DSA/DP/19-0-1-knapsack/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(n * wt) + O(n)</code></li> </ul>"},{"location":"DSA/DP/19-0-1-knapsack/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (maxWeight+1, 0));\n\n    // base case\n    for (int i=weight[0]; i&lt;=maxWeight; i++) dp[0][i] = value[0];\n\n    for (int i=1; i&lt;n; i++) {\n        for (int wt=0; wt&lt;=maxWeight; wt++) {\n            int notTake = dp[i-1][wt];\n            int take = 0;\n            if (weight[i] &lt;= wt) take = value[i] + dp[i-1][wt-weight[i]];\n\n            dp[i][wt] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][maxWeight];\n}\n</code></pre>"},{"location":"DSA/DP/19-0-1-knapsack/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(n * wt)</code></li> </ul>"},{"location":"DSA/DP/19-0-1-knapsack/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;int&gt; prev(maxWeight + 1, 0); // using maxWeight --&gt; 0, no need of curr\n\n    // base case\n    for (int i=weight[0]; i&lt;=maxWeight; i++) prev[i] = value[0];\n\n    for (int i=1; i&lt;n; i++) {\n        for (int wt=maxWeight; wt&gt;=0; wt--) {\n            int notTake = prev[wt];\n            int take = 0;\n            if (weight[i] &lt;= wt) take = value[i] + prev[wt-weight[i]];\n\n            prev[wt] = max(take, notTake);\n        }\n    }\n\n    return prev[maxWeight];\n}\n</code></pre>"},{"location":"DSA/DP/19-0-1-knapsack/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(wt)</code></li> </ul>"},{"location":"DSA/DP/19-0-1-knapsack/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/0-1-knapsack_920542</li> </ul>"},{"location":"DSA/DP/19-0-1-knapsack/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #knapsack #maximization</code></li> </ul>"},{"location":"DSA/DP/20-minimum-coins/","title":"20. Minimum Coins","text":""},{"location":"DSA/DP/20-minimum-coins/#description","title":"Description","text":"<ul> <li>Take minimum coins from the available denominations that sum to target.</li> </ul>"},{"location":"DSA/DP/20-minimum-coins/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/20-minimum-coins/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, int tar, vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        if (tar % num[0] == 0) return tar / num[0];\n        return 1e9;\n    }\n\n    if (dp[ind][tar] != -1) return dp[ind][tar];\n\n    int notTake = solve(ind-1, tar, num, dp);\n    int take = 1e9;\n    if (num[ind] &lt;= tar) take = 1 + solve(ind, tar-num[ind], num, dp);\n\n    return dp[ind][tar] = min(take, notTake);\n}\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (x+1, -1));\n\n    int ans = solve(n-1, x, num, dp);\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20-minimum-coins/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/20-minimum-coins/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (x+1, 0));\n\n    // base-case\n    for (int tar=0; tar&lt;=x; tar++) {\n        if (tar % num[0] == 0) dp[0][tar] = tar / num[0];\n        else dp[0][tar] = 1e9;\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=x; tar++) {\n            int notTake = dp[i-1][tar];\n            int take = 1e9;\n            if (num[i] &lt;= tar) take = 1 + dp[i][tar-num[i]];\n\n            dp[i][tar] = min(take, notTake);\n        }\n    }\n\n    int ans = dp[n-1][x];\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20-minimum-coins/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/20-minimum-coins/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;int&gt; prev(x+1, 0), curr(x+1, 0);\n\n    // base-case\n    for (int tar=0; tar&lt;=x; tar++) {\n        if (tar % num[0] == 0) prev[tar] = tar / num[0];\n        else prev[tar] = 1e9;\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=x; tar++) {\n            int notTake = prev[tar];\n            int take = 1e9;\n            if (num[i] &lt;= tar) take = 1 + curr[tar-num[i]];\n\n            curr[tar] = min(take, notTake);\n        }\n        prev = curr;\n    }\n\n    int ans = prev[x];\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20-minimum-coins/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/20-minimum-coins/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-elements_3843091 </li> </ul>"},{"location":"DSA/DP/20-minimum-coins/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #take-not-take #minimization</code></li> </ul>"},{"location":"DSA/DP/21-target-sum/","title":"21. Target Sum","text":""},{"location":"DSA/DP/21-target-sum/#description","title":"Description","text":"<ul> <li>Either you can add the number or subtract at a particular index.</li> <li>Make that equal to target sum.</li> <li>Same as 18th question.</li> </ul>"},{"location":"DSA/DP/21-target-sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/target-sum_4127362</li> </ul>"},{"location":"DSA/DP/21-target-sum/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #sum #subset-sum #subsequence</code></li> </ul>"},{"location":"DSA/DP/22-coin-change-2/","title":"22. Coin Change 2","text":""},{"location":"DSA/DP/22-coin-change-2/#description","title":"Description","text":"<ul> <li>Count total ways to make coins sum equal to Target</li> <li>Duplicate coins allowed</li> </ul>"},{"location":"DSA/DP/22-coin-change-2/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/22-coin-change-2/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong solve(int ind, int sum, int *denominations, int n, vector&lt;vector&lt;long&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        return (sum % denominations[0] == 0);\n    }\n\n    if (dp[ind][sum] != -1) return dp[ind][sum];\n\n    long notTake = solve(ind-1, sum, denominations, n, dp);\n    long take = 0;\n    if (denominations[ind] &lt;= sum) take = solve(ind, sum - denominations[ind], denominations, n, dp);\n\n    return dp[ind][sum] = take + notTake;\n}\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (value + 1, -1));\n\n    return solve(n-1, value, denominations, n, dp);\n}\n</code></pre>"},{"location":"DSA/DP/22-coin-change-2/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/22-coin-change-2/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (value + 1, 0));\n\n    for (int i=0; i&lt;=value; i++) {\n        dp[0][i] = (value % denominations[0] == 0);\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=value; tar++) {\n            long notTake = dp[i-1][tar];\n            long take = 0;\n            if (denominations[i] &lt;= tar) take = dp[i][tar - denominations[i]];\n\n            dp[i][tar] = take + notTake;\n        }\n    }\n\n    return dp[n-1][value];\n}\n</code></pre>"},{"location":"DSA/DP/22-coin-change-2/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/22-coin-change-2/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;long&gt; dp(value + 1, 0);\n\n    for (int i=0; i&lt;=value; i++) {\n        dp[i] = (value % denominations[0] == 0);\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        vector&lt;long&gt; curr(value + 1, 0);\n        for (int tar=0; tar&lt;=value; tar++) {\n            long notTake = dp[tar];\n            long take = 0;\n            if (denominations[i] &lt;= tar) take = curr[tar - denominations[i]];\n\n            curr[tar] = take + notTake;\n        }\n\n        dp = curr;\n    }\n\n    return dp[value];\n}\n</code></pre>"},{"location":"DSA/DP/22-coin-change-2/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/22-coin-change-2/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ways-to-make-coin-change_630471</li> </ul>"},{"location":"DSA/DP/22-coin-change-2/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #take-not-take #count</code></li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/","title":"23. Unbounded Knapsack","text":""},{"location":"DSA/DP/23-unbounded-knapsack/#description","title":"Description","text":"<ul> <li>Allowed to take one of the sack multiple times</li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/23-unbounded-knapsack/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint solve(int i, int rem, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0) {\n        return profit[0] * (rem / weight[i]);\n    }\n\n    if (dp[i][rem] != -1) return dp[i][rem];\n\n    int notTake = solve(i-1, rem, profit, weight, dp);\n    int take = 0;\n    if (weight[i] &lt;= rem) {\n        take = profit[i] + solve(i, rem - weight[i], profit, weight, dp);\n    }\n\n    return dp[i][rem] = max(take, notTake);\n}\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (w + 1, -1));\n\n    return solve(n-1, w, profit, weight, dp);\n}\n</code></pre>"},{"location":"DSA/DP/23-unbounded-knapsack/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (w + 1, 0));\n\n    for (int i=0; i&lt;=w; i++) {\n        dp[0][w] = (w / weight[0]) * profit[0];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int rem=0; rem&lt;=w; rem++) {\n            int notTake = dp[i-1][rem];\n            int take = 0;\n            if (weight[i] &lt;= rem) take = profit[i] + dp[i][rem - weight[i]];\n\n            dp[i][rem] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][w];\n}\n</code></pre>"},{"location":"DSA/DP/23-unbounded-knapsack/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;int&gt; prev(w+1, 0), curr(w+1, 0);\n\n    for (int i=0; i&lt;=w; i++) {\n        prev[w] = (w / weight[0]) * profit[0];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int rem=0; rem&lt;=w; rem++) {\n            int notTake = prev[rem];\n            int take = 0;\n            if (weight[i] &lt;= rem) take = profit[i] + curr[rem - weight[i]];\n\n            curr[rem] = max(take, notTake);\n        }\n\n        prev = curr;\n    }\n\n    return prev[w];\n}\n</code></pre>"},{"location":"DSA/DP/23-unbounded-knapsack/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/unbounded-knapsack_1215029</li> </ul>"},{"location":"DSA/DP/23-unbounded-knapsack/#tags","title":"Tags","text":""},{"location":"DSA/DP/24-rod-cutting-problem/","title":"24. Rod Cutting Problem","text":""},{"location":"DSA/DP/24-rod-cutting-problem/#description","title":"Description","text":"<ul> <li>Cut the rod into pieces maximizing the profit.</li> </ul>"},{"location":"DSA/DP/24-rod-cutting-problem/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/24-rod-cutting-problem/#1-memorization","title":"1) Memorization","text":"<pre><code>int solve(int ind, int remRod, vector&lt;int&gt; &amp;price, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        return price[0] * remRod;\n    }\n\n    if (dp[ind][remRod] != -1) return dp[ind][remRod];\n\n    int notTake = solve(ind-1, remRod, price, dp);\n\n    int take = 0;\n    if (remRod &gt;= ind+1) {\n        take = price[ind] + solve(ind, remRod - ind - 1, price, dp);\n    }\n\n    return dp[ind][remRod] = max(take, notTake);\n}\n\nint cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n+1, -1));\n\n    return solve(n-1, n, price, dp);\n}\n</code></pre>"},{"location":"DSA/DP/24-rod-cutting-problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/24-rod-cutting-problem/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n+1, 0));\n\n    for (int remRod=0; remRod&lt;=n; remRod++) {\n        dp[0][remRod] = price[0] * remRod;\n    }\n\n    for (int ind=1; ind&lt;n; ind++) {\n        for (int remRod=0; remRod&lt;=n; remRod++) {\n            int notTake = dp[ind-1][remRod];\n\n            int take = 0;\n            if (remRod &gt;= ind+1) {\n                take = price[ind] + dp[ind][remRod - ind - 1];\n            }\n\n            dp[ind][remRod] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][n];\n}\n</code></pre>"},{"location":"DSA/DP/24-rod-cutting-problem/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n)</code></li> </ul>"},{"location":"DSA/DP/24-rod-cutting-problem/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;int&gt; curr(n+1, 0), prev(n+1, 0);\n\n    for (int remRod=0; remRod&lt;=n; remRod++) {\n        prev[remRod] = price[0] * remRod;\n    }\n\n    for (int ind=1; ind&lt;n; ind++) {\n        for (int remRod=0; remRod&lt;=n; remRod++) {\n            int notTake = prev[remRod];\n\n            int take = 0;\n            if (remRod &gt;= ind+1) {\n                take = price[ind] + curr[remRod - ind - 1];\n            }\n\n            curr[remRod] = max(take, notTake);\n        }\n\n        prev = curr;\n    }\n\n    return prev[n];\n}\n</code></pre>"},{"location":"DSA/DP/24-rod-cutting-problem/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/24-rod-cutting-problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/rod-cutting-problem_800284</li> </ul>"},{"location":"DSA/DP/24-rod-cutting-problem/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #take-not-take #maximization</code></li> </ul>"},{"location":"DSA/DP/25-lcs/","title":"25. Lcs","text":""},{"location":"DSA/DP/25-lcs/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/25-lcs/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == -1 || j == -1) {\n        return 0;\n    }\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    if (s[i] == t[j]) return dp[i][j] = 1 + solve(i-1, j-1, s, t, dp);\n\n    return dp[i][j] = max(solve(i-1, j, s, t, dp), solve(i, j-1, s, t, dp));\n}\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n    return solve(n-1, m-1, s, t, dp);\n}\n</code></pre>"},{"location":"DSA/DP/25-lcs/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/25-lcs/#notes","title":"Notes","text":"<ul> <li>Match-NotMatch technique</li> <li>Check if it matches on index</li> <li>Else take optimized of reduced index by 1 differently</li> </ul>"},{"location":"DSA/DP/25-lcs/#2-tabulation","title":"2) Tabulation","text":"<ul> <li>Uses shifted DP, because -1 index base case is not possible.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 || j == 0) {\n        return 0;\n    }\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    if (s[i-1] == t[j-1]) return dp[i][j] = 1 + solve(i-1, j-1, s, t, dp);\n\n    return dp[i][j] = max(solve(i-1, j, s, t, dp), solve(i, j-1, s, t, dp));\n}\n\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n</code></pre>"},{"location":"DSA/DP/25-lcs/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/25-lcs/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n</code></pre>"},{"location":"DSA/DP/25-lcs/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/25-lcs/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-common-subsequence_624879</li> </ul>"},{"location":"DSA/DP/25-lcs/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #lcs #match-notMatch #strings</code></li> </ul>"},{"location":"DSA/DP/26-print-lcs/","title":"26. Print Lcs","text":""},{"location":"DSA/DP/26-print-lcs/#description","title":"Description","text":"<ul> <li>Use DP table of max LCS to solve this.</li> </ul>"},{"location":"DSA/DP/26-print-lcs/#solution","title":"Solution","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nstring findLCS(int n, int m, string &amp;s, string &amp;t){\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    string ans = \"\";\n    int ansLen = dp[n][m];\n    for (int i=0; i&lt;ansLen; i++) ans += '$';\n\n    int ind = ansLen-1, i = n, j = m;\n\n    while (i &gt; 0 &amp;&amp; j &gt; 0) {\n        if (s[i-1] == t[j-1]) {\n            ans[ind--] = s[i-1];\n            i--;\n            j--;\n        }\n        else if (dp[i][j-1] &gt;= dp[i-1][j]) {\n            j--;\n        } \n        else {\n            i--;\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/26-print-lcs/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/26-print-lcs/#notes","title":"Notes","text":""},{"location":"DSA/DP/26-print-lcs/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/print-longest-common-subsequence_8416383</li> </ul>"},{"location":"DSA/DP/26-print-lcs/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #match-notMatch #strings #lcs</code></li> </ul>"},{"location":"DSA/DP/27-longest-common-substring/","title":"27. Longest Common Substring","text":""},{"location":"DSA/DP/27-longest-common-substring/#description","title":"Description","text":"<ul> <li>Minor change in LCS - If not match, it is 0.</li> <li>Return max len in the DP Table</li> </ul>"},{"location":"DSA/DP/27-longest-common-substring/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/27-longest-common-substring/#1-tabulation","title":"1) Tabulation","text":"<pre><code>int lcs(string &amp;s, string &amp;t){\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    int ans = 0;\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n                ans = max(ans, dp[i][j]);\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/27-longest-common-substring/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/27-longest-common-substring/#notes","title":"Notes","text":""},{"location":"DSA/DP/27-longest-common-substring/#2-space-optimization","title":"2) Space Optimization","text":"<pre><code>int lcs(string &amp;s, string &amp;t){\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    int ans = 0;\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n                ans = max(ans, curr[j]);\n            } else {\n                curr[j] = 0;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/27-longest-common-substring/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/27-longest-common-substring/#notes_1","title":"Notes","text":""},{"location":"DSA/DP/27-longest-common-substring/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-common-substring_1235207</li> </ul>"},{"location":"DSA/DP/27-longest-common-substring/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #lcs #match-notMatch #strings</code></li> </ul>"},{"location":"DSA/DP/28-longest-palindromic-subsequence/","title":"28. Longest Palindromic Subsequence","text":""},{"location":"DSA/DP/28-longest-palindromic-subsequence/#description","title":"Description","text":"<ul> <li><code>lcs(s, rev(s))</code> is answer</li> </ul>"},{"location":"DSA/DP/28-longest-palindromic-subsequence/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/28-longest-palindromic-subsequence/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\nint longestPalindromeSubsequence(string s)\n{\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n\n    return lcs(s, rev);\n}\n</code></pre>"},{"location":"DSA/DP/28-longest-palindromic-subsequence/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/28-longest-palindromic-subsequence/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-palindromic-subsequence_842787</li> </ul>"},{"location":"DSA/DP/28-longest-palindromic-subsequence/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #lcs #match-notMatch #strings</code></li> </ul>"},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/","title":"29. Minimum Insertions To Make String Palindrome","text":""},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#description","title":"Description","text":"<ul> <li><code>len(s) - lps(s)</code></li> </ul>"},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\nint longestPalindromeSubsequence(string s)\n{\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n\n    return lcs(s, rev);\n}\n\nint minimumInsertions(string &amp;str)\n{\n    return str.size() - longestPalindromeSubsequence(str);\n}\n</code></pre>"},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-insertions-to-make-a-string-palindrome_985293</li> </ul>"},{"location":"DSA/DP/29-minimum-insertions-to-make-string-palindrome/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #match-notMatch #strings #lcs</code></li> </ul>"},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/","title":"30. Minimum Insertions Or Deletions To Convert String A To String B","text":""},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#description","title":"Description","text":"<p><code>int deletions = s1.size() - lcs(s1, s2);</code>int insertions = s2.size() - lcs(s1, s2);<code></code>return deletions + insertions;</p>"},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\n\nint canYouMake(string &amp;s1, string &amp;s2){\n    int deletions = s1.size() - lcs(s1, s2);\n    int insertions = s2.size() - lcs(s1, s2);\n\n    return deletions + insertions;\n}\n</code></pre>"},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-number-of-deletions-and-insertions_4244510</li> </ul>"},{"location":"DSA/DP/30-minimum-insertions-or-deletions-to-convert-string-a-to-string-b/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #match-notMatch #strings #lcs</code></li> </ul>"},{"location":"DSA/DP/31-shortest-common-supersequence/","title":"31. Shortest Common Supersequence","text":""},{"location":"DSA/DP/31-shortest-common-supersequence/#description","title":"Description","text":"<ul> <li><code>n + m - lcs(s, t)</code></li> <li>Construct string from DP table</li> </ul>"},{"location":"DSA/DP/31-shortest-common-supersequence/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/31-shortest-common-supersequence/#1-tabulation","title":"1) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \nstring shortestSupersequence(string s, string t)\n{\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    string ans = \"\";\n\n    int i = n, j = m;\n\n    while (i &gt; 0 &amp;&amp; j &gt; 0) {\n        if (s[i-1] == t[j-1]) {\n            ans += s[i-1];\n            i--;\n            j--;\n        }\n        else if (dp[i][j-1] &gt;= dp[i-1][j]) {\n            ans += t[j-1];\n            j--;\n        } \n        else {\n            ans += s[i-1];\n            i--;\n        }\n    }\n\n    while (i &gt; 0) {\n        ans += s[i-1];\n        i--;\n    }\n\n\n    while (j &gt; 0) {\n        ans += t[j-1];\n        j--;\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/31-shortest-common-supersequence/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/31-shortest-common-supersequence/#notes","title":"Notes","text":""},{"location":"DSA/DP/31-shortest-common-supersequence/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/shortest-supersequence_4244493</li> </ul>"},{"location":"DSA/DP/31-shortest-common-supersequence/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #match-notMatch #strings #lcs</code></li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/","title":"32. Distinct Subsequences","text":""},{"location":"DSA/DP/32-distinct-subsequences/#description","title":"Description","text":"<ul> <li>Find no. of distinct subsequences of s which equals t</li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/32-distinct-subsequences/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == -1) return 1;\n\n        if (i == -1) return 0;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i] == t[j]) {\n            return dp[i][j] = solve(i-1, j-1, s, t, dp) + solve(i-1, j, s, t, dp);\n        }\n\n        return dp[i][j] = solve(i-1, j, s, t, dp);\n    }\n\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1)); \n        return solve(n-1, m-1, s, t, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32-distinct-subsequences/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n\n    // for reference - shifted arrays\n    int solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == 0) return 1;\n\n        if (i == 0) return 0;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i-1] == t[j-1]) {\n            return dp[i][j] = solve(i-1, j-1, s, t, dp) + solve(i-1, j, s, t, dp);\n        }\n\n        return dp[i][j] = solve(i-1, j, s, t, dp);\n    }\n\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n\n        for (int i=0; i&lt;=n; i++) {\n            dp[i][0] = 1;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == t[j-1]) {\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n\n        return (int)dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32-distinct-subsequences/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n        vector&lt;unsigned long long&gt; prev(m+1, 0), curr(m+1, 0);\n\n        prev[0] = curr[0] = 1;\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == t[j-1]) {\n                    curr[j] = prev[j-1] + prev[j];\n                } else {\n                    curr[j] = prev[j];\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32-distinct-subsequences/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#3-space-optimization-1d","title":"3) Space Optimization - 1D","text":"<pre><code>class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n        vector&lt;unsigned long long&gt; prev(m+1, 0);\n\n        prev[0] = 1;\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=m; j&gt;=1; j--) {\n                if (s[i-1] == t[j-1]) {\n                    prev[j] = prev[j-1] + prev[j];\n                } else {\n                    prev[j] = prev[j];\n                }\n            }\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32-distinct-subsequences/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/distinct-subsequences/</li> </ul>"},{"location":"DSA/DP/32-distinct-subsequences/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #strings</code></li> </ul>"},{"location":"DSA/DP/33-edit-distance/","title":"33. Edit Distance","text":""},{"location":"DSA/DP/33-edit-distance/#description","title":"Description","text":"<ul> <li>Insert, Delete or replace in str1 to make it equal to str2</li> <li>Return min operations</li> </ul>"},{"location":"DSA/DP/33-edit-distance/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/33-edit-distance/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;word1, string &amp;word2, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == -1) return i + 1;\n\n        if (i == -1) return j + 1;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (word1[i] == word2[j]) return dp[i][j] = solve(i-1, j-1, word1, word2, dp);\n\n        return dp[i][j] = 1 + min({\n            solve(i-1, j-1, word1, word2, dp), \n            solve(i, j-1, word1, word2, dp), \n            solve(i-1, j, word1, word2, dp)\n        });\n    }\n\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n        return solve(n-1, m-1, word1, word2, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33-edit-distance/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n+m)</code></li> </ul>"},{"location":"DSA/DP/33-edit-distance/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;word1, string &amp;word2, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == 0) return i;\n\n        if (i == 0) return j;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (word1[i-1] == word2[j-1]) return dp[i][j] = solve(i-1, j-1, word1, word2, dp);\n\n        return dp[i][j] = 1 + min({\n            solve(i-1, j-1, word1, word2, dp), \n            solve(i, j-1, word1, word2, dp), \n            solve(i-1, j, word1, word2, dp)\n        });\n    }\n\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n        for (int i=0; i&lt;=n; i++) {\n            dp[i][0] = i;\n        }\n\n        for (int j=0; j&lt;=m; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                }\n                else {\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33-edit-distance/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/33-edit-distance/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n        for (int i=0; i&lt;=m; i++) {\n            prev[i] = i;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            curr[0] = i;\n            for (int j=1; j&lt;=m; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    curr[j] = prev[j-1];\n                }\n                else {\n                    curr[j] = 1 + min({prev[j-1], curr[j-1], prev[j]});\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33-edit-distance/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/33-edit-distance/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/edit-distance/</li> </ul>"},{"location":"DSA/DP/33-edit-distance/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #strings</code></li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/","title":"34. Wildcard Matching","text":""},{"location":"DSA/DP/34-wildcard-matching/#description","title":"Description","text":"<ul> <li>Match string pattern with string str.</li> <li>patterns contains ? or * or letters</li> <li> <ul> <li>means any string (0 or more letters)</li> </ul> </li> <li>? means single letter</li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/34-wildcard-matching/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n\n    bool solve(int i, int j, string &amp;s, string &amp;p, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (i == -1 &amp;&amp; j == -1) return true;\n\n        if (j == -1) return false;\n\n        if (i == -1) {\n            for (int k=0; k&lt;=j; k++) {\n                if (p[k] != '*') return false;\n            }\n\n            return true;\n        }\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i] == p[j] || p[j] == '?') {\n            return dp[i][j] = solve(i-1, j-1, s, p, dp);\n        }\n\n        if (p[j] == '*') {\n            return dp[i][j] = solve(i, j-1, s, p, dp) | solve(i-1, j, s, p, dp);\n        }\n\n        return dp[i][j] = false;\n    }\n\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n        return solve(n-1, m-1, s, p, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34-wildcard-matching/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;vector&lt;bool&gt;&gt; dp(n+1, vector&lt;bool&gt; (m+1, false));\n\n        dp[0][0] = true;\n\n        for (int i=1; i&lt;=n; i++) {\n            dp[i][0] = false;\n        }\n\n        for (int j=1; j&lt;=m; j++) {\n            dp[0][j] = p[j-1] == '*' &amp;&amp; dp[0][j-1];\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == p[j-1] || p[j-1] == '?') {\n                    dp[i][j] = dp[i-1][j-1];\n                } else if (p[j-1] == '*') {\n                    dp[i][j] = dp[i][j-1] | dp[i-1][j];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34-wildcard-matching/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;bool&gt; prev(m+1, false), curr(m+1, false);\n\n        prev[0] = true;\n\n        for (int j=1; j&lt;=m; j++) {\n            prev[j] = p[j-1] == '*' &amp;&amp; prev[j-1];\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == p[j-1] || p[j-1] == '?') {\n                    curr[j] = prev[j-1];\n                } else if (p[j-1] == '*') {\n                    curr[j] = curr[j-1] | prev[j];\n                } else {\n                    curr[j] = false;\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34-wildcard-matching/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/wildcard-matching/</li> </ul>"},{"location":"DSA/DP/34-wildcard-matching/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #strings</code></li> </ul>"},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/","title":"35. Best Time To Buy And Sell Stock","text":""},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/#description","title":"Description","text":"<ul> <li>Can be traded only once.</li> </ul>"},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/#solutions","title":"Solutions","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \nint maximumProfit(vector&lt;int&gt; &amp;prices){\n    int mini = prices[0], profit = 0;\n\n    for (int i=1; i&lt;prices.size(); i++) {\n        profit = max(profit, prices[i] - mini);\n        mini = min(mini, prices[i]);\n    }\n\n    return profit;\n}\n</code></pre>"},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/stocks-are-profitable_893405</li> </ul>"},{"location":"DSA/DP/35-best-time-to-buy-and-sell-stock/#tags","title":"Tags","text":"<ul> <li><code>#dp #stocks</code></li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/","title":"36. Best Time To Buy And Sell Stock - Ii","text":""},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#description","title":"Description","text":"<ul> <li>Can be traded multiple times.</li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint N;\n\nlong solve(int ind, int buyAllowed, long *values, vector&lt;vector&lt;long&gt;&gt; &amp;dp) {\n    if (ind == N) return 0;\n\n    if (dp[ind][buyAllowed] != -1) return dp[ind][buyAllowed];\n\n    if (buyAllowed == 0) {\n        long sell = values[ind] + solve(ind+1, 1, values, dp);\n        long notSell = solve(ind+1, 0, values, dp);\n\n        return dp[ind][buyAllowed] = max(sell, notSell);\n    }\n    else {\n        long buy = -values[ind] + solve(ind+1, 0, values, dp);\n        long notBuy = solve(ind+1, 1, values, dp);\n        return dp[ind][buyAllowed] = max(buy, notBuy);\n    }\n}\n\nlong getMaximumProfit(long *values, int n)\n{\n    N = n;\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (2, -1));\n\n    return solve(0, 1, values, dp);\n}\n</code></pre>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2) + O(n)</code></li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nlong getMaximumProfit(long *values, int n)\n{\n    vector&lt;vector&lt;long&gt;&gt; dp(n+1, vector&lt;long&gt; (2, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -values[ind] + dp[ind+1][0];\n        long notBuy = dp[ind+1][1];\n\n        dp[ind][1] = max(buy, notBuy);\n\n        long sell = values[ind] + dp[ind+1][1];\n        long notSell = dp[ind+1][0];\n\n        dp[ind][0] = max(sell, notSell);\n    }\n\n    return dp[0][1];\n}\n</code></pre>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2)</code></li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nlong getMaximumProfit(long *values, int n)\n{\n    vector&lt;long&gt; ahead(2, 0), curr(2, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -values[ind] + ahead[0];\n        long notBuy = ahead[1];\n\n        curr[1] = max(buy, notBuy);\n\n        long sell = values[ind] + ahead[1];\n        long notSell = ahead[0];\n\n        curr[0] = max(sell, notSell);\n\n        ahead = curr;\n    }\n\n    return ahead[1];\n}\n</code></pre>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-ii_630282</li> </ul>"},{"location":"DSA/DP/36-best-time-to-buy-and-sell-stock-ii/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #stocks</code></li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/","title":"37. Best Time To Buy And Sell Stock - Iii","text":""},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#description","title":"Description","text":"<ul> <li>Can be traded only 2 times maximum.</li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint solve(int ind, int buyAllowed, int rem, vector&lt;int&gt; &amp;prices, int &amp;n, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; &amp;dp) {\n    if (ind == n || rem == 0) return 0;\n\n    if (dp[ind][buyAllowed][rem] != -1) return dp[ind][buyAllowed][rem];\n\n    if (buyAllowed) {\n        int buy = -prices[ind] + solve(ind+1, 0, rem, prices, n, dp);\n        int notBuy = solve(ind+1, 1, rem, prices, n, dp);\n\n        return dp[ind][buyAllowed][rem] = max(buy, notBuy);\n    } \n    else {\n        int sell = prices[ind] + solve(ind+1, 1, rem-1, prices, n, dp);\n        int notSell = solve(ind+1, 0, rem, prices, n, dp);\n\n        return dp[ind][buyAllowed][rem] = max(sell, notSell);\n    }\n}\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;int&gt;&gt; (2, vector&lt;int&gt; (3, -1)));\n\n    return solve(0, 1, 2, prices, n, dp);\n}\n</code></pre>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(n * 2 * 3) + O(n)</code></li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;int&gt;&gt; (2, vector&lt;int&gt; (3, 0)));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=2; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + dp[ind+1][0][rem];\n                    int notBuy = dp[ind+1][1][rem];\n\n                    dp[ind][buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + dp[ind+1][1][rem-1];\n                    int notSell = dp[ind+1][0][rem];\n\n                    dp[ind][buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n    }\n\n    return dp[0][1][2];\n}\n</code></pre>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(n * 2 * 3)</code></li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;int&gt;&gt; ahead(2, vector&lt;int&gt; (3, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(2, vector&lt;int&gt; (3, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=2; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + ahead[0][rem];\n                    int notBuy = ahead[1][rem];\n\n                    curr[buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + ahead[1][rem-1];\n                    int notSell = ahead[0][rem];\n\n                    curr[buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n\n        ahead = curr;\n    }\n\n    return ahead[1][2];\n}\n</code></pre>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-iii_1071012</li> </ul>"},{"location":"DSA/DP/37-best-time-to-buy-and-sell-stock-iii/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #stocks</code></li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/","title":"38 best time to buy and sell stock iv","text":""},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#description","title":"Description","text":"<ul> <li>Allowed at most K transactions.</li> <li>Same as 37.</li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; ahead(2, vector&lt;int&gt; (k+1, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(2, vector&lt;int&gt; (k+1, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=k; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + ahead[0][rem];\n                    int notBuy = ahead[1][rem];\n\n                    curr[buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + ahead[1][rem-1];\n                    int notSell = ahead[0][rem];\n\n                    curr[buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n\n        ahead = curr;\n    }\n\n    return ahead[1][k];\n}\n</code></pre>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#another-approach-transaction-method","title":"Another Approach (Transaction Method)","text":"<ul> <li>Even transaction no. means BUY, odd means SELL</li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#1-memoization","title":"1) Memoization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int ind, int tranNo, vector&lt;int&gt; &amp;prices, int &amp;n, int &amp;k, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == n || tranNo == 2*k) return 0;\n\n    if (dp[ind][tranNo] != -1) return dp[ind][tranNo];\n\n    // buy\n    if (tranNo % 2 == 0) {\n        return dp[ind][tranNo] = max(-prices[ind] + solve(ind+1, tranNo+1, prices, n, k, dp),\n                                solve(ind+1, tranNo, prices, n, k, dp));\n    }\n    else {\n        return dp[ind][tranNo] = max(prices[ind] + solve(ind+1, tranNo+1, prices, n, k, dp),\n                                solve(ind+1, tranNo, prices, n, k, dp));\n    }\n}\n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (2*k, -1));\n    return solve(0, 0, prices, n, k, dp);\n}\n</code></pre>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(n * 2 * k) + O(n)</code></li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (2*k+1, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int tranNo=0; tranNo&lt;=2*k-1; tranNo++) {\n            if (tranNo % 2 == 0) {\n                dp[ind][tranNo] = max(-prices[ind] + dp[ind+1][tranNo+1], dp[ind+1][tranNo]);\n            }\n            else {\n                dp[ind][tranNo] = max(prices[ind] + dp[ind+1][tranNo+1], dp[ind+1][tranNo]);\n            }\n        }\n    }\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(n * 2 * k)</code></li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;int&gt; ahead(2*k+1, 0), curr(2*k+1, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int tranNo=0; tranNo&lt;=2*k-1; tranNo++) {\n            if (tranNo % 2 == 0) {\n                curr[tranNo] = max(-prices[ind] + ahead[tranNo+1], ahead[tranNo]);\n            }\n            else {\n                curr[tranNo] = max(prices[ind] + ahead[tranNo+1], ahead[tranNo]);\n            }\n        }\n\n        ahead = curr;\n    }\n    return ahead[0];\n}\n</code></pre>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock_1080698</li> </ul>"},{"location":"DSA/DP/38-best-time-to-buy-and-sell-stock-iv/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #stocks</code></li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/","title":"39. Best Time To Buy And Sell Stock With Cooldown","text":""},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#description","title":"Description","text":"<ul> <li>After sell call omit 1 index</li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n\n    int solve(int ind, int buyAllowed, vector&lt;int&gt; &amp;prices, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (ind &gt;= prices.size()) return 0;\n\n        if (dp[ind][buyAllowed] != -1) return dp[ind][buyAllowed];\n\n        if (buyAllowed) {\n            return dp[ind][buyAllowed] = max(\n                -prices[ind] + solve(ind+1, 0, prices, dp),\n                solve(ind+1, 1, prices, dp)\n            );\n        }\n        else {\n            return dp[ind][buyAllowed] = max(\n                prices[ind] + solve(ind+2, 1, prices, dp),\n                solve(ind+1, 0, prices, dp)\n            );\n        }\n    }\n\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (2, -1));\n        return solve(0, 1, prices, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2) + O(n)</code></li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n+2, vector&lt;int&gt; (2, 0));\n\n        for (int ind=n-1; ind&gt;=0; ind--) {\n            dp[ind][1] = max(-prices[ind] + dp[ind+1][0], dp[ind+1][1]);\n            dp[ind][0] = max(prices[ind] + dp[ind+2][1], dp[ind+1][0]);\n        }\n\n        return dp[0][1];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2)</code></li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;int&gt; front2(2, 0);\n        vector&lt;int&gt; front1(2, 0);\n        vector&lt;int&gt; curr(2, 0);\n\n        for (int ind=n-1; ind&gt;=0; ind--) {\n            curr[1] = max(-prices[ind] + front1[0], front1[1]);\n            curr[0] = max(prices[ind] + front2[1], front1[0]);\n\n            front2 = front1;\n            front1 = curr;\n        }\n\n        return curr[1];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</li> </ul>"},{"location":"DSA/DP/39-best-time-to-buy-and-sell-stock-with-cooldown/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #stocks</code></li> </ul>"},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/","title":"40. Best Time To Buy And Sell Stock With Transaction Fee","text":""},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/#solution","title":"Solution","text":""},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int fee)\n{\n    vector&lt;long&gt; ahead(2, 0), curr(2, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -prices[ind] + ahead[0];\n        long notBuy = ahead[1];\n\n        curr[1] = max(buy, notBuy);\n\n        long sell = prices[ind] - fee + ahead[1];\n        long notSell = ahead[0];\n\n        curr[0] = max(sell, notSell);\n\n        ahead = curr;\n    }\n\n    return ahead[1];\n}\n</code></pre>"},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-with-transaction-fee_3118974</li> </ul>"},{"location":"DSA/DP/40-best-time-to-buy-and-sell-stock-with-transaction-fee/#tags","title":"Tags","text":"<ul> <li><code>#dp #recursion #stocks</code></li> </ul>"},{"location":"DSA/Recursion/01-print-all-subsequences/","title":"1. Print All Subsequences","text":""},{"location":"DSA/Recursion/01-print-all-subsequences/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid subseq(int ind, vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;ds) {\n    if (ind == a.size()) {\n        for (auto num : ds) {\n            cout &lt;&lt; num &lt;&lt; \" \";\n        }\n\n        if (ds.size() == 0) {\n            cout &lt;&lt; \"{}\";\n        }\n\n        cout &lt;&lt; endl;\n        return;\n    };\n\n    // take\n    ds.push_back(a[ind]);\n    subseq(ind + 1, a, ds);\n    ds.pop_back();\n\n    // not-take\n    subseq(ind + 1, a, ds);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);   \n\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n\n    subseq(0, a, ds);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/01-print-all-subsequences/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code> <ul> <li>2^n for all subseq</li> <li>n for printing</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/01-print-all-subsequences/#tags","title":"Tags","text":"<ul> <li><code>#recursion #take-not-take #subsequence</code></li> </ul>"},{"location":"DSA/Recursion/02-print-all-subsequence-having-sum-k/","title":"2. Print All Subsequence Having Sum K","text":""},{"location":"DSA/Recursion/02-print-all-subsequence-having-sum-k/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid sum_K(int ind, vector&lt;int&gt; &amp;ds, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        if (sum == k) {\n            for (auto num : ds) {\n                cout &lt;&lt; num &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n        }\n        return;\n    }\n\n    // take\n    ds.push_back(a[ind]);\n    sum += a[ind];\n    sum_K(ind + 1, ds, a, sum, k);\n    ds.pop_back();\n    sum -= a[ind];\n\n    // not-take\n    sum_K(ind + 1, ds, a, sum, k);\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n    int sum = 0;\n    sum_K(0, ds, a, sum, k);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/02-print-all-subsequence-having-sum-k/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code><ul> <li>2^n for all subseq</li> <li>n for printing</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/02-print-all-subsequence-having-sum-k/#tags","title":"Tags","text":"<ul> <li><code>#recursion #take-not-take #subsequence #sum-k</code></li> </ul>"},{"location":"DSA/Recursion/03-print-anyone-subsequence-with-sum-k/","title":"3. Print Anyone Subsequence With Sum K","text":""},{"location":"DSA/Recursion/03-print-anyone-subsequence-with-sum-k/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nbool sum_K(int ind, vector&lt;int&gt; &amp;ds, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        // condition - satisfied\n        if (sum == k) {\n            for (auto num : ds) {\n                cout &lt;&lt; num &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n            return true;\n        }\n\n        // condition - not satisfied\n        return false;\n    }\n\n    // take\n    ds.push_back(a[ind]);\n    sum += a[ind];\n\n    if (sum_K(ind + 1, ds, a, sum, k) == true) {\n        return true;\n    }\n\n    ds.pop_back();\n    sum -= a[ind];\n\n    // not-take\n    if (sum_K(ind + 1, ds, a, sum, k) == true) {\n        return true;\n    }\n\n    return false;\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n    int sum = 0;\n\n    if (!sum_K(0, ds, a, sum, k)) {\n\u00a0 \u00a0 \u00a0 \u00a0 cout &lt;&lt; \"No subsequence\";\n\u00a0 \u00a0 }\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/03-print-anyone-subsequence-with-sum-k/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/03-print-anyone-subsequence-with-sum-k/#tags","title":"Tags","text":"<ul> <li><code>#recursion #sum-k #subsequence #take-not-take #only-one</code></li> </ul>"},{"location":"DSA/Recursion/04-count-all-subsequences-with-sum-k/","title":"4. Count All Subsequences With Sum K","text":""},{"location":"DSA/Recursion/04-count-all-subsequences-with-sum-k/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint sum_K(int ind, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        // condition - satisfied\n        if (sum == k) {\n            return 1;\n        }\n\n        // condition - not satisfied\n        return 0;\n    }\n\n    // take\n    sum += a[ind];\n\n    int l = sum_K(ind + 1, a, sum, k);\n\n    sum -= a[ind];\n\n    // not-take\n    int r = sum_K(ind + 1, a, sum, k);\n\n    return l + r;\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    int sum = 0;\n\n    cout &lt;&lt; sum_K(0, a, sum, k);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/04-count-all-subsequences-with-sum-k/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/04-count-all-subsequences-with-sum-k/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/04-count-all-subsequences-with-sum-k/#tags","title":"Tags","text":"<ul> <li><code>#recursion #subsequence #sum-k #take-not-take #count</code></li> </ul>"},{"location":"DSA/Recursion/05-merge-sort/","title":"5. Merge Sort","text":""},{"location":"DSA/Recursion/05-merge-sort/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid merge(vector&lt;int&gt; &amp;a, int low, int mid, int high) {\n    vector&lt;int&gt; temp;\n\n    int left = low;\n    int right = mid + 1;\n\n    while (left &lt;= mid &amp;&amp; right &lt;= high) {\n        if (a[left] &lt;= a[right]) {\n            temp.push_back(a[left]);\n            left++;\n        } \n        else {\n            temp.push_back(a[right]);\n            right++;\n        }\n    }\n\n    while (left &lt;= mid) {\n        temp.push_back(a[left]);\n        left++;\n    }\n\n    while (right &lt;= high) {\n        temp.push_back(a[right]);\n        right++;\n    }\n\n    for (int i=low; i&lt;=high; i++) {\n        a[i] = temp[i - low];\n    }\n}\n\nvoid mergeSort(vector&lt;int&gt; &amp;a, int low, int high) {\n\n    // base-condition\n    if (low &gt;= high) return;\n\n    int mid = (low + high) / 2;\n\n    // left\n    mergeSort(a, low, mid);\n    // right\n    mergeSort(a, mid + 1, high);\n\n    // merge\n    merge(a, low, mid, high);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    mergeSort(a, 0, n - 1);\n\n    for (int i=0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/05-merge-sort/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code><ul> <li>n for merge at each level</li> <li>logn for the levels of tree</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/05-merge-sort/#tags","title":"Tags","text":"<ul> <li><code>#recursion #merge-sort #sorting #divide-and-conquer #algorithm</code></li> </ul>"},{"location":"DSA/Recursion/06-quick-sort/","title":"6. Quick Sort","text":""},{"location":"DSA/Recursion/06-quick-sort/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint partition(vector&lt;int&gt; &amp;a, int low, int high) {\n    int pivot = a[low];\n\n    int i = low, j = high;\n\n    while (i &lt; j) {\n        while (a[i] &lt;= pivot &amp;&amp; i &lt;= high - 1) {\n            i++;\n        }\n\n        while (a[j] &gt; pivot &amp;&amp; j &gt;= low + 1) {\n            j--;\n        }\n\n        if (i &lt; j) {\n            swap(a[i], a[j]);\n        }\n    }\n\n    swap(a[low], a[j]);\n\n    return j;\n}\n\nvoid quickSort(vector&lt;int&gt; &amp;a, int low, int high) {\n    if (low &gt;= high) return;\n\n    int pivot = partition(a, low, high);\n    // left\n    quickSort(a, low, pivot - 1);\n\n    // right\n    quickSort(a, pivot + 1, high);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    quickSort(a, 0, n - 1);\n\n    for (int i=0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/06-quick-sort/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/Recursion/06-quick-sort/#tags","title":"Tags","text":"<ul> <li><code>#recursion #quick-sort #sorting #algorithm #divide-and-conquer</code></li> </ul>"},{"location":"DSA/Recursion/07-combination-sum-1/","title":"7. Combination Sum 1","text":""},{"location":"DSA/Recursion/07-combination-sum-1/#description","title":"Description","text":"<ul> <li>From a list of distinct numbers, find all unique combinations which sums to target. Same element can be taken more than once.</li> </ul>"},{"location":"DSA/Recursion/07-combination-sum-1/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ind == arr.size()) {\n            if (target == 0) ans.push_back(ds);\n            return;\n        }\n\n        // take\n        if (arr[ind] &lt;= target) {\n            ds.push_back(arr[ind]);\n            recurse(ind, target - arr[ind], arr, ds, ans);\n            ds.pop_back();\n        }\n\n        // not-take\n        recurse(ind + 1, target, arr, ds, ans);\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n\n        recurse(0, target, candidates, ds, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/07-combination-sum-1/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^t * k)</code></li> <li>Space Complexity: <code>O(k * x)</code></li> </ul>"},{"location":"DSA/Recursion/07-combination-sum-1/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/combination-sum/</li> </ul>"},{"location":"DSA/Recursion/07-combination-sum-1/#tags","title":"Tags","text":"<ul> <li><code>#recursion #take-not-take #sum #combination-sum</code></li> </ul>"},{"location":"DSA/Recursion/08-combination-sum-2/","title":"8. Combination Sum 2","text":""},{"location":"DSA/Recursion/08-combination-sum-2/#description","title":"Description","text":"<ul> <li>From a list of numbers, find all unique combinations which sums to target. Each number can be used only once in a combination.</li> </ul>"},{"location":"DSA/Recursion/08-combination-sum-2/#solution","title":"Solution","text":"<pre><code>class Solution {\n    public:\n        void recurse(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n            if (target == 0) {\n                ans.push_back(ds);\n                return;\n            }\n\n            for (int i=ind; i&lt;arr.size(); i++) {\n                if (i &gt; ind &amp;&amp; arr[i] == arr[i-1]) continue;\n\n                if (arr[i] &gt; target) break;\n\n                ds.push_back(arr[i]);\n                recurse(i + 1, target - arr[i], arr, ds, ans);\n                ds.pop_back();\n            }\n        }\n\n        vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n            sort(candidates.begin(), candidates.end());\n            vector&lt;int&gt; ds;\n            vector&lt;vector&lt;int&gt;&gt; ans;\n\n            recurse(0, target, candidates, ds, ans);\n\n            return ans;\n        }\n    };\n</code></pre>"},{"location":"DSA/Recursion/08-combination-sum-2/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^t * k)</code></li> <li>Space Complexity: <code>O(k * x)</code></li> </ul>"},{"location":"DSA/Recursion/08-combination-sum-2/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/08-combination-sum-2/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/combination-sum-ii/</li> </ul>"},{"location":"DSA/Recursion/08-combination-sum-2/#tags","title":"Tags","text":"<ul> <li><code>#recursion #sum #combination-sum</code></li> </ul>"},{"location":"DSA/Recursion/09-subset-sum-1/","title":"9. Subset Sum 1","text":""},{"location":"DSA/Recursion/09-subset-sum-1/#description","title":"Description","text":"<ul> <li>Return the sums of all the subsets possible.</li> </ul>"},{"location":"DSA/Recursion/09-subset-sum-1/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    void recurse(int ind, int &amp;sum, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ans) {\n        if (ind == arr.size()) {\n            ans.push_back(sum);\n            return;\n        }\n\n        // take\n        sum += arr[ind];\n        recurse(ind + 1, sum, arr, ans);\n        sum -= arr[ind];\n\n        // not-take\n        recurse(ind + 1, sum, arr, ans);\n    }\n\n    vector&lt;int&gt; subsetSums(vector&lt;int&gt;&amp; arr) {\n        vector&lt;int&gt; ans;\n        int sum = 0;\n\n        recurse(0, sum, arr, ans);\n\n        sort(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/09-subset-sum-1/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(2^n)</code></li> </ul>"},{"location":"DSA/Recursion/09-subset-sum-1/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/subset-sums2234/1</li> </ul>"},{"location":"DSA/Recursion/09-subset-sum-1/#tags","title":"Tags","text":"<ul> <li><code>#recursion #subset #sum #subset-sum #take-not-take</code></li> </ul>"},{"location":"DSA/Recursion/10-subset-sum-2/","title":"10. Subset Sum 2","text":""},{"location":"DSA/Recursion/10-subset-sum-2/#description","title":"Description","text":"<ul> <li>Return all possible subsets of an array. The array can contain duplicates.</li> </ul>"},{"location":"DSA/Recursion/10-subset-sum-2/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        ans.push_back(ds);\n\n        for (int i=ind; i&lt;nums.size(); i++) {\n            if (i &gt; ind &amp;&amp; nums[i] == nums[i-1]) continue;\n\n            ds.push_back(nums[i]);\n            recurse(i + 1, nums, ds, ans);\n            ds.pop_back();\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n\n        sort(nums.begin(), nums.end());\n\n        recurse(0, nums, ds, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/10-subset-sum-2/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code></li> <li>Space Complexity: <code>O(2^n * k)</code></li> </ul>"},{"location":"DSA/Recursion/10-subset-sum-2/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/subsets-ii</li> </ul>"},{"location":"DSA/Recursion/10-subset-sum-2/#tags","title":"Tags","text":"<ul> <li><code>#recursion #sum #subset-sum #subset</code></li> </ul>"},{"location":"DSA/Recursion/11-permutation/","title":"11. Permutation","text":""},{"location":"DSA/Recursion/11-permutation/#description","title":"Description","text":"<ul> <li>Return all the permutation of an array with distinct elements.</li> </ul>"},{"location":"DSA/Recursion/11-permutation/#solution-1-using-boolean-taken-array","title":"Solution 1 - Using boolean taken array","text":"<pre><code>class Solution {\npublic:\n    void recurse(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;ds, vector&lt;bool&gt; &amp;taken, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ds.size() == nums.size()) {\n            ans.push_back(ds);\n            return;\n        }\n\n        for (int i=0; i&lt;nums.size(); i++) {\n            if (!taken[i]) {\n                taken[i] = true;\n                ds.push_back(nums[i]);\n                recurse(nums, ds, taken, ans);\n                ds.pop_back();\n                taken[i] = false;        \n            }\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n        vector&lt;bool&gt; taken(n, 0);\n\n        recurse(nums, ds, taken, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/11-permutation/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n! * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/11-permutation/#solution-2-without-taken-array-using-swapping","title":"Solution 2 - Without taken array; using swapping","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ind == nums.size()) {\n            ans.push_back(nums);\n            return;\n        }\n\n        for (int i=ind; i&lt;nums.size(); i++) {\n            swap(nums[i], nums[ind]);\n            recurse(ind + 1, nums, ans);\n            swap(nums[i], nums[ind]);\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        recurse(0, nums, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/11-permutation/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n! * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/11-permutation/#notes","title":"Notes","text":"<p>Approach 2:</p> <p></p>"},{"location":"DSA/Recursion/11-permutation/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/permutations/</li> </ul>"},{"location":"DSA/Recursion/11-permutation/#tags","title":"Tags","text":"<ul> <li><code>#recursion #permutation</code></li> </ul>"},{"location":"DSA/Recursion/12-n-queens-problem/","title":"12. N-queens Problem","text":""},{"location":"DSA/Recursion/12-n-queens-problem/#description","title":"Description","text":"<ul> <li>For n sized chessboard, place n queens such that:<ul> <li>Each row has exactly 1 queen</li> <li>Each col has exactly 1 queen</li> <li>Queens should not attach each other</li> </ul> </li> </ul>"},{"location":"DSA/Recursion/12-n-queens-problem/#solution-1","title":"Solution 1","text":"<pre><code>class Solution {\npublic:\n\n    bool isValid(int row, int col, int &amp;n, vector&lt;string&gt; &amp;board) {\n\n        // check left\n        for (int c=0; c&lt;col; c++) {\n            if (board[row][c] == 'Q') return false;\n        }\n\n        // check upper-diagonal\n        int r = row - 1, c = col - 1;\n        while (r &gt;= 0 &amp;&amp; c &gt;= 0) {\n            if (board[r][c] == 'Q') return false;\n            r--;\n            c--;\n        }\n\n        // check lower-diagonal\n        r = row + 1, c = col - 1;\n        while (r &lt; n &amp;&amp; c &gt;= 0) {\n            if (board[r][c] == 'Q') return false;\n            r++;\n            c--;\n        }\n\n        return true;\n    }\n\n    void recurse(int col, int &amp;n, vector&lt;string&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (col == n) {\n            ans.push_back(board);\n            return;\n        }\n\n        for (int row=0; row&lt;n; row++) {\n            if (isValid(row, col, n, board)) {\n                board[row][col] = 'Q';\n                recurse(col + 1, n, board, ans);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        string s(n, '.');\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board(n, s);\n\n        recurse(0, n, board, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/12-n-queens-problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n^2 * n!)</code> due to pruning n^n is reduced to n!</li> <li>Space Complexity: <code>O(n^2 + n!)</code></li> </ul>"},{"location":"DSA/Recursion/12-n-queens-problem/#solution-2-optimizing-issafe-logic","title":"Solution 2 - Optimizing isSafe Logic","text":"<pre><code>class Solution {\npublic:\n\n    vector&lt;int&gt; leftRow, lowDiag, upDiag;\n\n    void recurse(int col, int &amp;n, vector&lt;string&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (col == n) {\n            ans.push_back(board);\n            return;\n        }\n\n        for (int row=0; row&lt;n; row++) {\n            if (!leftRow[row] &amp;&amp; !upDiag[(n - 1) + (col - row)] &amp;&amp; !lowDiag[row + col]) {\n                board[row][col] = 'Q';\n\n                leftRow[row] = true;\n                lowDiag[row + col] = true;\n                upDiag[(n - 1) + (col - row)] = true;\n\n                recurse(col + 1, n, board, ans);\n\n                board[row][col] = '.';\n\n                leftRow[row] = false;\n                lowDiag[row + col] = false;\n                upDiag[(n - 1) + (col - row)] = false;\n            }\n        }\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        string s(n, '.');\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board(n, s);\n\n        leftRow.resize(n, 0);\n        lowDiag.resize(2*n - 1, 0);\n        upDiag.resize(2*n - 1, 0);\n\n        recurse(0, n, board, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/12-n-queens-problem/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n!)</code></li> <li>Space Complexity: <code>O(n^2 + n!)</code></li> </ul>"},{"location":"DSA/Recursion/12-n-queens-problem/#notes","title":"Notes","text":"<p>For optimizing isSafe Logic </p>"},{"location":"DSA/Recursion/12-n-queens-problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/n-queens/</li> </ul>"},{"location":"DSA/Recursion/12-n-queens-problem/#tags","title":"Tags","text":"<ul> <li><code>#recursion #n-queens</code></li> </ul>"},{"location":"DSA/Recursion/13-sudoku-solver/","title":"13. Sudoku Solver","text":""},{"location":"DSA/Recursion/13-sudoku-solver/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool isValid(char chr, int r, int c, vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i=0; i&lt;9; i++) {\n            // row\n            if (chr == board[r][i]) return false;\n\n            // col\n            if (chr == board[i][c]) return false;\n\n            // box\n            if (chr == board[3 * (r/3) + i/3][3 * (c/3) + i%3]) return false;\n        }\n\n        return true;\n    }\n\n    bool recurse(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int r=0; r&lt;board.size(); r++) {\n            for (int c=0; c&lt;board.size(); c++) {\n                if (board[r][c] == '.') {\n                    for (char chr = '1'; chr &lt;= '9'; chr++) {\n                        if (isValid(chr, r, c, board)) {\n                            board[r][c] = chr;\n\n                            if (recurse(board))\n                                return true;\n                            else\n                                board[r][c] = '.';\n                        }\n                    }\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        recurse(board);\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/13-sudoku-solver/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(9^81)</code> in worst case but much lower in practical scenarios due to pruning and constraints.</li> <li>Space Complexity: <code>O(81) = O(1)</code></li> </ul>"},{"location":"DSA/Recursion/13-sudoku-solver/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/13-sudoku-solver/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/sudoku-solver/</li> </ul>"},{"location":"DSA/Recursion/13-sudoku-solver/#tags","title":"Tags","text":"<ul> <li><code>#recursion #sudoku</code></li> </ul>"},{"location":"DSA/Recursion/14-m-coloring-problem/","title":"14. M-coloring Problem","text":""},{"location":"DSA/Recursion/14-m-coloring-problem/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    bool isValid(int node, int color, vector&lt;vector&lt;int&gt;&gt; &amp;adj, vector&lt;int&gt; &amp;col) {\n        for (auto ngbr : adj[node]) {\n            if (col[ngbr] == color)\n                return false;\n        }\n\n        return true;\n    }\n\n    bool recurse(int node, int &amp;v, int &amp;m, vector&lt;vector&lt;int&gt;&gt; &amp;adj, vector&lt;int&gt; &amp;col) {\n        if (node == v)\n            return true;\n\n        for (int i=1; i&lt;=m; i++) {\n            if (isValid(node, i, adj, col)) {\n                col[node] = i;\n                if (recurse(node + 1, v, m, adj, col)) return true;\n                col[node] = 0;\n            }\n        }\n\n        return false;\n    }\n\n    bool graphColoring(int v, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges, int m) {\n        vector&lt;vector&lt;int&gt;&gt; adj(v);\n\n        for (auto &amp;edge : edges) {\n            adj[edge.first].push_back(edge.second);\n            adj[edge.second].push_back(edge.first);\n        }\n\n        vector&lt;int&gt; col(v, 0);\n\n        return recurse(0, v, m, adj, col);\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/14-m-coloring-problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(N^M)</code> N = no of nodes, M = colors</li> <li>Space Complexity: <code>O(N)</code></li> </ul>"},{"location":"DSA/Recursion/14-m-coloring-problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1</li> </ul>"},{"location":"DSA/Recursion/14-m-coloring-problem/#tags","title":"Tags","text":"<ul> <li><code>#recursion #m-coloring</code></li> </ul>"},{"location":"DSA/Recursion/15-palindrome-partitioning/","title":"15. Palindrome Partitioning","text":""},{"location":"DSA/Recursion/15-palindrome-partitioning/#description","title":"Description","text":"<ul> <li>Return all possible partitions of strings which are all palindromes.</li> </ul>"},{"location":"DSA/Recursion/15-palindrome-partitioning/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool check_palindrome(int i, int j, string &amp;s) {\n        while (i &lt; j) {\n            if (s[i] != s[j])\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    void recurse(int ind, string &amp;s, vector&lt;string&gt; &amp;ds, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (ind == s.size()) {\n            ans.push_back(ds);\n            return;\n        }\n\n        for (int i=ind; i&lt;s.size(); i++) {\n            if (check_palindrome(ind, i, s)) {\n                ds.push_back(s.substr(ind, i - ind + 1));\n                recurse(i + 1, s, ds, ans);\n                ds.pop_back();\n            }\n        }\n    } \n\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; ds;\n\n        recurse(0, s, ds, ans);\n\n        return ans;      \n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/15-palindrome-partitioning/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code></li> <li>Space Complexity: <code>O(2^n * n)</code></li> </ul>"},{"location":"DSA/Recursion/15-palindrome-partitioning/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/15-palindrome-partitioning/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/palindrome-partitioning/</li> </ul>"},{"location":"DSA/Recursion/15-palindrome-partitioning/#tags","title":"Tags","text":"<ul> <li><code>#recursion #palindrome</code></li> </ul>"},{"location":"DSA/Recursion/16-rat-in-a-maze/","title":"16. Rat In A Maze","text":""},{"location":"DSA/Recursion/16-rat-in-a-maze/#description","title":"Description","text":"<ul> <li>Find all possible paths to go from (0, 0) to (n-1, n-1). 0 means water and 1 means land.</li> </ul>"},{"location":"DSA/Recursion/16-rat-in-a-maze/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    vector&lt;int&gt; di = {1, 0, 0, -1};\n    vector&lt;int&gt; dj = {0, -1, 1, 0};\n\n    void recurse(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;mat, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, string &amp;path, vector&lt;string&gt; &amp;ans) {\n\n        if (i == mat.size() - 1 &amp;&amp; j == mat.size() - 1) {\n            ans.push_back(path);\n            return;\n        }\n\n        string dir = \"DLRU\";\n\n        for (int ind=0; ind&lt;4; ind++) {\n            int x = i + di[ind];\n            int y = j + dj[ind];\n\n            if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; mat.size() &amp;&amp; y &lt; mat.size() &amp;&amp; !vis[x][y] &amp;&amp; mat[x][y]) {\n                vis[i][j] = true;\n                path.push_back(dir[ind]);\n                recurse(x, y, mat, vis, path, ans);\n                path.pop_back();\n                vis[i][j] = false;\n            }\n        }\n    }\n\n    vector&lt;string&gt; findPath(vector&lt;vector&lt;int&gt;&gt; &amp;mat) {\n        vector&lt;string&gt; ans;\n        string path;\n        int n = mat.size();\n        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(n, 0));\n\n        if (mat[0][0]) recurse(0, 0, mat, vis, path, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/16-rat-in-a-maze/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(4^(n*m))</code></li> <li>Space Complexity: <code>O(n*m)</code></li> </ul>"},{"location":"DSA/Recursion/16-rat-in-a-maze/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/16-rat-in-a-maze/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/rat-in-a-maze-problem/1</li> </ul>"},{"location":"DSA/Recursion/16-rat-in-a-maze/#tags","title":"Tags","text":"<ul> <li><code>#recursion #land-water #grid</code></li> </ul>"},{"location":"DSA/Recursion/17-k-th-permutation/","title":"17. K-th Permutation","text":""},{"location":"DSA/Recursion/17-k-th-permutation/#solution","title":"Solution","text":"<ul> <li>Do recursion and find the kth permutation. </li> <li>But it would be a brute force.</li> <li>Here is the optimal solution.</li> </ul> <pre><code>class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector&lt;int&gt; v(n);\n        string ans = \"\";\n\n        for (int i=0; i&lt;n; i++) v[i] = i + 1;\n\n        int fact = 1;\n        for (int i=1; i&lt;n; i++) fact *= i;\n        k--;\n\n        while (n != 1) {\n            int ind = k / fact;\n            ans += v[ind] + '0';\n            v.erase(v.begin() + ind);\n            k = k % fact;\n            n--;\n            fact /= n;\n        }\n\n        ans += v[0] + '0';\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/17-k-th-permutation/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n*n) = O(n^2)</code><ul> <li>1st n for all the numbers in a permutation</li> <li>2nd n for erasing that number from the left array</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/17-k-th-permutation/#notes","title":"Notes","text":""},{"location":"DSA/Recursion/17-k-th-permutation/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/permutation-sequence/</li> </ul>"},{"location":"DSA/Recursion/17-k-th-permutation/#tags","title":"Tags","text":"<ul> <li><code>#recursion</code></li> </ul>"},{"location":"DSA/Recursion/18-count-no-of-inversions/","title":"18. Count No. Of Inversions","text":""},{"location":"DSA/Recursion/18-count-no-of-inversions/#description","title":"Description","text":"<ul> <li>count pairs (i, j) where i &lt; j and a[i] &gt; a[j]</li> </ul>"},{"location":"DSA/Recursion/18-count-no-of-inversions/#solution-merge-sort","title":"Solution (merge sort)","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint merge(vector&lt;int&gt; &amp;a, int low, int mid, int high) {\n    int cnt = 0;\n    vector&lt;int&gt; temp;\n\n    int left = low;\n    int right = mid + 1;\n\n    while (left &lt;= mid &amp;&amp; right &lt;= high) {\n        if (a[left] &lt;= a[right]) {\n            temp.push_back(a[left]);\n            left++;\n        } \n        else {\n            temp.push_back(a[right]);\n            cnt += (mid - left + 1);\n            right++;\n        }\n    }\n\n    while (left &lt;= mid) {\n        temp.push_back(a[left]);\n        left++;\n    }\n\n    while (right &lt;= high) {\n        temp.push_back(a[right]);\n        right++;\n    }\n\n    for (int i=low; i&lt;=high; i++) {\n        a[i] = temp[i - low];\n    }\n\n    return cnt;\n}\n\nint mergeSort(vector&lt;int&gt; &amp;a, int low, int high) {\n    int cnt = 0;\n\n    // base-condition\n    if (low &gt;= high) return cnt;\n\n    int mid = (low + high) / 2;\n\n    // left\n    cnt += mergeSort(a, low, mid);\n    // right\n    cnt += mergeSort(a, mid + 1, high);\n\n    // merge\n    cnt += merge(a, low, mid, high);\n\n    return cnt;\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    cout &lt;&lt; mergeSort(a, 0, n - 1);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/18-count-no-of-inversions/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/18-count-no-of-inversions/#resources","title":"Resources","text":"<ul> <li>Problem Link: </li> </ul>"},{"location":"DSA/Recursion/18-count-no-of-inversions/#tags","title":"Tags","text":"<ul> <li><code>#recursion #merge-sort #count #inversions</code></li> </ul>"}]}