{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/","title":"1) Nth Fibonacci Nummber","text":""},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nint f(int n, vector&lt;int&gt; &amp;dp) {\n    if (n &lt;= 1) return 1;\n\n    if (dp[n] != -1) return dp[n];\n\n    return dp[n] = f(n-1, dp) + f(n-2, dp);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; dp(n + 1, -1);\n    cout &lt;&lt; f(n, dp);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code> rec stack space + dp array</li> </ul>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; dp(n + 1, -1);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i=2; i&lt;=n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n\n    cout &lt;&lt; dp[n];\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    int prev2 = 0, prev = 1;\n    int curr;\n\n    if (n &lt;= 1) {\n        cout &lt;&lt; n;\n        return;\n    }\n\n    for (int i=2; i&lt;=n; i++) {\n        curr = prev + prev2;\n        prev2 = prev;\n        prev = curr;\n    }\n\n    cout &lt;&lt; curr;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#tags","title":"Tags","text":""},{"location":"DSA/DP/1%29%20Nth%20Fibonacci%20Nummber/#recursion-dp-fibonacci","title":"recursion #dp #fibonacci","text":""},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/","title":"10) Grid Minimum Path Sum","text":""},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 &amp;&amp; j == 0) return grid[i][j];\n\n    if (i &lt; 0 || j &lt; 0) return 1e9;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = grid[i][j] + solve(i-1, j, grid, dp);\n    int left = grid[i][j] + solve(i, j-1, grid, dp);\n\n    return dp[i][j] = min(up, left);\n}\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    return solve(n-1, m-1, grid, dp);\n}\n</code></pre>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: `O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)``</li> </ul>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n    dp[0][0] = grid[0][0];\n\n    for (int i=0; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            if (i == 0 &amp;&amp; j == 0) continue;\n            else {\n                int up = 1e9, left = 1e9;\n                if (i &gt; 0) up = grid[i][j] + dp[i-1][j];\n                if (j &gt; 0) left = grid[i][j] + dp[i][j-1];\n\n                dp[i][j] = min(up, left);\n            }\n        }\n    }\n\n    return dp[n-1][m-1];\n}\n</code></pre>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minSumPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n\n    vector&lt;int&gt; prev_row(m, 0);\n\n    for (int i=0; i&lt;n; i++) {\n        vector&lt;int&gt; row(m, 0);\n        for (int j=0; j&lt;m; j++) {\n            if (i == 0 &amp;&amp; j == 0) row[0] = grid[i][j];\n            else {\n                int up = 1e9, left = 1e9;\n                if (i &gt; 0) up = grid[i][j] + prev_row[j];\n                if (j &gt; 0) left = grid[i][j] + row[j-1];\n\n                row[j] = min(up, left);\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[m-1];\n}\n</code></pre>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-path-sum_985349</li> </ul>"},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#tags","title":"Tags","text":""},{"location":"DSA/DP/10%29%20Grid%20Minimum%20Path%20Sum/#dp-recursion-sum-grid","title":"dp #recursion #sum #grid","text":""},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/","title":"11) Triangle   Fixed Starting Point and Variable Ending Point","text":""},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#description","title":"Description","text":"<ul> <li>Minimize path sum by going only down or right diagonal.</li> </ul>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, int &amp;n, vector&lt;vector&lt;int&gt;&gt; &amp;triangle, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == n-1) return triangle[i][j];\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int down = triangle[i][j] + solve(i+1, j, n, triangle, dp);\n    int diagonal = triangle[i][j] + solve(i+1, j+1, n, triangle, dp);\n\n    return dp[i][j] = min(down, diagonal);\n}\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n, -1));\n    return solve(0, 0, n, triangle, dp);\n}\n</code></pre>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n) + O(n * n)</code></li> </ul>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n, 0));\n\n    // base case\n    for (int j=0; j&lt;n; j++) {\n        dp[n-1][j] = triangle[n-1][j];\n    }\n\n    for (int i=n-2; i&gt;=0; i--) {\n        for (int j=i; j&gt;=0; j--) {\n            int down = triangle[i][j] + dp[i+1][j];\n            int diagonal = triangle[i][j] + dp[i+1][j+1];\n\n            dp[i][j] = min(down, diagonal);\n        }\n    }\n\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n)</code></li> </ul>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int n){\n    vector&lt;int&gt; prev_row(n, 0);\n\n    // base case\n    for (int j=0; j&lt;n; j++) {\n        prev_row[j] = triangle[n-1][j];\n    }\n\n    for (int i=n-2; i&gt;=0; i--) {\n        vector&lt;int&gt; row(n, 0);\n        for (int j=i; j&gt;=0; j--) {\n            int down = triangle[i][j] + prev_row[j];\n            int diagonal = triangle[i][j] + prev_row[j+1];\n\n            row[j] = min(down, diagonal);\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[0];\n}\n</code></pre>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/triangle_1229398</li> </ul>"},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#tags","title":"Tags","text":""},{"location":"DSA/DP/11%29%20Triangle%20-%20Fixed%20Starting%20Point%20and%20Variable%20Ending%20Point/#dp-recursion-sum-minimization-grid","title":"dp #recursion #sum #minimization #grid","text":""},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/","title":"12) Maximum Falling Path Sum","text":""},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#description","title":"Description","text":"<ul> <li>Start from any cell in first row and reach any cell in last row to maximize sum.</li> </ul>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint n, m;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (j &gt;= m || j &lt; 0) return -1e6;\n\n    if (i == 0) return matrix[i][j];\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int u = matrix[i][j] + solve(i-1, j, matrix, dp);\n    int ld = matrix[i][j] + solve(i-1, j-1, matrix, dp);\n    int rd = matrix[i][j] + solve(i-1, j+1, matrix, dp);\n\n    return dp[i][j] = max({u, ld, rd});\n}\n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    n = matrix.size();\n    m = matrix[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, solve(n-1, j, matrix, dp));\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n)</code></li> </ul>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n\n    // base case\n    for (int j=0; j&lt;m; j++) {\n        dp[0][j] = matrix[0][j];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            int u = -1e6, ld = -1e6, rd = -1e6;\n\n            u = matrix[i][j] + dp[i-1][j];\n            if (j-1 &gt;= 0) ld = matrix[i][j] + dp[i-1][j-1];\n            if (j+1 &lt; m) rd = matrix[i][j] + dp[i-1][j+1];\n\n            dp[i][j] = max({u, ld, rd});\n        }\n    }\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, dp[n-1][j]);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#notes","title":"Notes","text":""},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint getMaxPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector&lt;int&gt; prev(m, 0), curr(m, 0);\n\n    // base case\n    for (int j=0; j&lt;m; j++) {\n        prev[j] = matrix[0][j];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            int u = -1e6, ld = -1e6, rd = -1e6;\n\n            u = matrix[i][j] + prev[j];\n            if (j-1 &gt;= 0) ld = matrix[i][j] + prev[j-1];\n            if (j+1 &lt; m) rd = matrix[i][j] + prev[j+1];\n\n            curr[j] = max({u, ld, rd});\n        }\n\n        prev = curr;\n    }\n\n    int ans = -1e6;\n\n    for (int j=0; j&lt;m; j++) {\n        ans = max(ans, prev[j]);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/maximum-path-sum-in-the-matrix_797998</li> </ul>"},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#tags","title":"Tags","text":""},{"location":"DSA/DP/12%29%20Maximum%20Falling%20Path%20Sum/#dp-recursion-sum-maximization-grid","title":"dp #recursion #sum #maximization #grid","text":""},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/","title":"13) 3D DP   Grid","text":""},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#description","title":"Description","text":"<ul> <li>Alice starts from (0,0) and bob starts from (0, c-1)</li> <li>Both can go down or diagonally down.</li> <li>Maximize sum (if both go in same cell, count only once)</li> </ul>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int i, int j1, int j2, int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; &amp;dp) {\n\n    // base cases\n    if (j1 &lt; 0 || j1 &gt;= c || j2 &lt; 0 || j2 &gt;= c) return -1e9;\n\n    if (i == r-1) {\n        if (j1 == j2) return grid[i][j1];\n        else return grid[i][j1] + grid[i][j2];\n    }\n\n    if (dp[i][j1][j2] != -1) return dp[i][j1][j2];\n\n    // explore all paths of alice and bob simultaneously\n\n    int maxi = 0;\n\n    for (int d1 = -1; d1 &lt;= 1; d1++) {\n        for (int d2 = -1; d2 &lt;= 1; d2++) {\n            int value = 0;\n\n            if (j1 == j2) value += grid[i][j1];\n            else value += grid[i][j1] + grid[i][j2];\n\n            value += solve(i+1, j1+d1, j2+d2, r, c, grid, dp);\n\n            maxi = max(maxi, value);\n        }\n    }\n\n    return dp[i][j1][j2] = maxi;\n}\n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(r, vector&lt;vector&lt;int&gt;&gt; (c, vector&lt;int&gt; (c, -1)));\n    return solve(0, 0, c-1, r, c, grid, dp);\n}\n</code></pre>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(r * c * c) + O(r)</code></li> </ul>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(r, vector&lt;vector&lt;int&gt;&gt; (c, vector&lt;int&gt; (c, 0)));\n\n    // base case\n    for (int j1 = 0; j1 &lt; c; j1++) {\n        for (int j2 = 0; j2 &lt; c; j2++) {\n            if (j1 == j2) dp[r-1][j1][j2] = grid[r-1][j1];\n            else dp[r-1][j1][j2] = grid[r-1][j1] + grid[r-1][j2];\n        }\n    }\n\n    for (int i=r-2; i&gt;=0; i--) {\n        for (int j1=0; j1&lt;c; j1++) {\n            for (int j2=0; j2&lt;c; j2++) {\n                int maxi = 0;\n\n                for (int d1 = -1; d1 &lt;= 1; d1++) {\n                    for (int d2 = -1; d2 &lt;= 1; d2++) {\n                        int value = 0;\n\n                        if (j1 == j2) value += grid[i][j1];\n                        else value += grid[i][j1] + grid[i][j2];\n\n                        if (j1+d1 &gt;= 0 &amp;&amp; j1+d1 &lt; c &amp;&amp; j2+d2 &gt;= 0 &amp;&amp; j2+d2 &lt; c)\n                            value += dp[i+1][j1+d1][j2+d2];\n                        else \n                            value += -1e9;\n\n                        maxi = max(maxi, value);\n                    }\n                } \n\n                dp[i][j1][j2] = maxi;\n            }\n        }\n    }\n\n    return dp[0][0][c-1];\n}\n</code></pre>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(r * c * c)</code></li> </ul>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumChocolates(int r, int c, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    vector&lt;vector&lt;int&gt;&gt; prev(c, vector&lt;int&gt; (c, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(c, vector&lt;int&gt; (c, 0));\n\n    // base case\n    for (int j1 = 0; j1 &lt; c; j1++) {\n        for (int j2 = 0; j2 &lt; c; j2++) {\n            if (j1 == j2) prev[j1][j2] = grid[r-1][j1];\n            else prev[j1][j2] = grid[r-1][j1] + grid[r-1][j2];\n        }\n    }\n\n    for (int i=r-2; i&gt;=0; i--) {\n        for (int j1=0; j1&lt;c; j1++) {\n            for (int j2=0; j2&lt;c; j2++) {\n                int maxi = 0;\n\n                for (int d1 = -1; d1 &lt;= 1; d1++) {\n                    for (int d2 = -1; d2 &lt;= 1; d2++) {\n                        int value = 0;\n\n                        if (j1 == j2) value += grid[i][j1];\n                        else value += grid[i][j1] + grid[i][j2];\n\n                        if (j1+d1 &gt;= 0 &amp;&amp; j1+d1 &lt; c &amp;&amp; j2+d2 &gt;= 0 &amp;&amp; j2+d2 &lt; c)\n                            value += prev[j1+d1][j2+d2];\n                        else \n                            value += -1e9;\n\n                        maxi = max(maxi, value);\n                    }\n                } \n\n                curr[j1][j2] = maxi;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[0][c-1];\n}\n</code></pre>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(r * c * c) * 9</code></li> <li>Space Complexity: <code>O(c * c)</code></li> </ul>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ninja-and-his-friends_3125885</li> </ul>"},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#tags","title":"Tags","text":""},{"location":"DSA/DP/13%29%203D%20DP%20-%20Grid/#dp-recursion-sum-maximization-grid-3d-dp","title":"dp #recursion #sum #maximization #grid #3d-dp","text":""},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/","title":"14) Subset Sum Equal to K","text":""},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#description","title":"Description","text":"<ul> <li>Check if any subset sums to K or not.</li> </ul>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool solve(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (target == 0) return true;\n\n    if (ind == 0) return arr[0] == target;\n\n    if (dp[ind][target] != -1) return dp[ind][target];\n\n    bool notTake = solve(ind - 1, target, arr, dp);\n    bool take = false;\n\n    if (target &gt;= arr[ind])\n        take = solve(ind - 1, target - arr[ind], arr, dp);\n\n    return dp[ind][target] = take | notTake;\n}\n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, -1));\n\n    return solve(n-1, k, arr, dp);   \n}\n</code></pre>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt; (k+1, 0));\n\n    // base cases\n    for (int i=0; i&lt;n; i++) dp[i][0] = true;\n    if (arr[0] &lt;= k) dp[0][arr[0]] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = dp[i-1][target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = dp[i-1][target-arr[i]];\n\n            dp[i][target] = take | notTake;\n        }\n    }\n\n    return dp[n-1][k];\n}\n</code></pre>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nbool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n</code></pre>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/subset-sum-equal-to-k_1550954</li> </ul>"},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#tags","title":"Tags","text":""},{"location":"DSA/DP/14%29%20Subset%20Sum%20Equal%20to%20K/#dp-recursion-sum-subsequence-subset-subset-sum","title":"dp #recursion #sum #subsequence #subset #subset-sum","text":""},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/","title":"15) Partition Equal Subset Sum","text":""},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#description","title":"Description","text":"<ul> <li>Use 14th question logic.</li> </ul>"},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#space-optimization","title":"Space Optimization","text":"<pre><code>bool subsetSumToK(int n, int k, vector&lt;int&gt; &amp;arr) {\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n\nbool canPartition(vector&lt;int&gt; &amp;arr, int n) {\n    int sum = 0;\n\n    for (int i=0; i&lt;n; i++) sum += arr[i];\n\n    if (sum % 2) return false;\n\n    int target = sum / 2;\n\n    return subsetSumToK(n, target, arr);\n}\n</code></pre>"},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partition-equal-subset-sum-_892980</li> </ul>"},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#tags","title":"Tags","text":""},{"location":"DSA/DP/15%29%20Partition%20Equal%20Subset%20Sum/#dp-recursion-sum-equal-subsequence-subset-subset-sum","title":"dp #recursion #sum #equal #subsequence #subset #subset-sum","text":""},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/","title":"16) Partition A Set Into Two Subsets With Minimum Absolute Sum Difference","text":""},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#description","title":"Description","text":"<ul> <li>Use 14th question approach.</li> </ul>"},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#space-optimization","title":"Space Optimization","text":"<pre><code>int minSubsetSumDifference(vector&lt;int&gt;&amp; arr, int n) {\n\n    int totSum = 0;\n\n    for (int i=0; i&lt;n; i++) totSum += arr[i];\n\n    int k = totSum / 2;\n\n    vector&lt;bool&gt; prev(k+1, 0), curr(k+1, 0);\n\n    // base cases\n    prev[0] = true;\n    if (arr[0] &lt;= k) prev[arr[0]] = true;\n    curr[0] = true;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int target = 1; target &lt;= k; target++) {\n            bool notTake = prev[target];\n            bool take = false;\n            if (target &gt;= arr[i]) take = prev[target-arr[i]];\n\n            curr[target] = take | notTake;\n        }\n\n        prev = curr;\n    }\n\n    int miniDiff = 1e9;\n\n    for (int i=0; i&lt;=k; i++) {\n        if (prev[i] == true) {\n            int absDiff = abs(i - (totSum - i));\n            miniDiff = min(miniDiff, absDiff);\n        }\n    }\n\n    return miniDiff;\n}\n</code></pre>"},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum_842494</li> </ul>"},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#tags","title":"Tags","text":""},{"location":"DSA/DP/16%29%20Partition%20A%20Set%20Into%20Two%20Subsets%20With%20Minimum%20Absolute%20Sum%20Difference/#dp-recursion-subset-sum-sum-subset-subsequence-minimization","title":"dp #recursion #subset-sum #sum #subset #subsequence #minimization","text":""},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/","title":"17) Count Subsets with Sum K","text":""},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#1-memorization","title":"1) Memorization","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint solve(int ind, int sum, vector&lt;int&gt; &amp;arr, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n\n    if (ind == 0) {\n        if (sum == 0) {\n            if (arr[0] == 0) return 2;\n            return 1;\n        }\n\n        return (arr[0] == sum);\n    }\n\n    if (dp[ind][sum] != -1) return dp[ind][sum];\n\n    int notPick = solve(ind-1, sum, arr, dp);\n    int pick = 0;\n    if (arr[ind] &lt;= sum) \n        pick = solve(ind-1, sum-arr[ind], arr, dp);\n\n    return dp[ind][sum] = (pick + notPick) % mod;\n}\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, -1));\n\n    return solve(n-1, k, arr, dp);\n}\n</code></pre>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: <code>O(n * k) + O(n)</code></li> </ul>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, 0));\n\n    if (arr[0] == 0) dp[0][0] = 2;\n    else dp[0][0] = 1;\n\n    if (arr[0] != 0 &amp;&amp; arr[0] &lt;= k) dp[0][arr[0]] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum = 0; sum &lt;= k; sum++) {\n            int notPick = dp[i-1][sum];\n            int pick = 0;\n            if (arr[i] &lt;= sum) \n                pick = dp[i-1][sum-arr[i]];\n\n            dp[i][sum] = (pick + notPick) % mod;\n        }\n    }\n\n    return dp[n-1][k];\n}\n</code></pre>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: `O(n * k)</li> </ul>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int mod = (int)1e9 + 7;\n\nint findWays(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (k+1, 0));\n    vector&lt;int&gt; prev(k+1, 0), curr(k+1, 0);\n\n    if (arr[0] == 0) prev[0] = 2;\n    else prev[0] = 1;\n\n    if (arr[0] != 0 &amp;&amp; arr[0] &lt;= k) prev[arr[0]] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum = 0; sum &lt;= k; sum++) {\n            int notPick = prev[sum];\n            int pick = 0;\n            if (arr[i] &lt;= sum) \n                pick = prev[sum-arr[i]];\n\n            curr[sum] = (pick + notPick) % mod;\n        }\n\n        prev = curr;\n    }\n\n    return prev[k];\n}\n</code></pre>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/number-of-subsets_3952532</li> </ul>"},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#tags","title":"Tags","text":""},{"location":"DSA/DP/17%29%20Count%20Subsets%20with%20Sum%20K/#dp-recursion-count-subset-subset-sum-subsequence","title":"dp #recursion #count #subset #subset-sum #subsequence","text":""},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/","title":"18) Count partitions with given difference","text":""},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#description","title":"Description","text":"<ul> <li>S1 - S2 = D and S1 &gt;= S2</li> <li>Therefore, totSum - 2*S2 = D =&gt; S2 = (totSum - D) / 2</li> </ul>"},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#space-optimization","title":"Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint mod = (int)(1e9 + 7);\n\nint findWays(vector&lt;int&gt; &amp;arr, int tar) {\n    int n = arr.size();\n\n    vector&lt;int&gt; prev(tar + 1, 0), curr(tar + 1, 0);\n\n    if (arr[0] &lt;= tar) prev[arr[0]] = 1;\n\n    if (arr[0] == 0) prev[0] = 2;\n    else prev[0] = 1;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int sum=0; sum&lt;=tar; sum++) {\n            int notTake = prev[sum];\n            int take = 0;\n            if (arr[i] &lt;= sum) take = prev[sum-arr[i]];\n\n            curr[sum] = (take + notTake) % mod;\n        }\n\n        prev = curr;\n    }\n\n    return prev[tar];\n}\n\nint countPartitions(int n, int d, vector&lt;int&gt; &amp;arr) {\n    int totSum = 0;\n\n    for (int i=0; i&lt;n; i++) totSum += arr[i];\n\n    if ((totSum - d) % 2 || (totSum - d) &lt; 0) return 0;\n\n    int tar = (totSum - d) / 2;\n\n    return findWays(arr, tar);\n}\n</code></pre>"},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * tar)</code></li> <li>Space Complexity: <code>O(tar)</code></li> </ul>"},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/partitions-with-given-difference_3751628</li> </ul>"},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#tags","title":"Tags","text":""},{"location":"DSA/DP/18%29%20Count%20partitions%20with%20given%20difference/#dp-recursion-sum-subset-sum-subsequence","title":"dp #recursion #sum #subset-sum #subsequence","text":""},{"location":"DSA/DP/19%29%200%201%20Knapsack/","title":"19) 0 1 Knapsack","text":""},{"location":"DSA/DP/19%29%200%201%20Knapsack/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/19%29%200%201%20Knapsack/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int ind, int wt, vector&lt;int&gt; &amp;weight, vector&lt;int&gt; &amp;value, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        if (weight[0] &lt;= wt) return value[0];\n        return 0;\n    }\n\n    if (dp[ind][wt] != -1) return dp[ind][wt];\n\n    int notTake = solve(ind-1, wt, weight, value, dp);\n    int take = 0;\n    if (weight[ind] &lt;= wt) take = value[ind] + solve(ind-1, wt-weight[ind], weight, value, dp);\n\n    return dp[ind][wt] = max(take, notTake);\n}\n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (maxWeight+1, -1));\n\n    return solve(n-1, maxWeight, weight, value, dp);\n}\n</code></pre>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(n * wt) + O(n)</code></li> </ul>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (maxWeight+1, 0));\n\n    // base case\n    for (int i=weight[0]; i&lt;=maxWeight; i++) dp[0][i] = value[0];\n\n    for (int i=1; i&lt;n; i++) {\n        for (int wt=0; wt&lt;=maxWeight; wt++) {\n            int notTake = dp[i-1][wt];\n            int take = 0;\n            if (weight[i] &lt;= wt) take = value[i] + dp[i-1][wt-weight[i]];\n\n            dp[i][wt] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][maxWeight];\n}\n</code></pre>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(n * wt)</code></li> </ul>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint knapsack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int n, int maxWeight) {\n    vector&lt;int&gt; prev(maxWeight + 1, 0); // using maxWeight --&gt; 0, no need of curr\n\n    // base case\n    for (int i=weight[0]; i&lt;=maxWeight; i++) prev[i] = value[0];\n\n    for (int i=1; i&lt;n; i++) {\n        for (int wt=maxWeight; wt&gt;=0; wt--) {\n            int notTake = prev[wt];\n            int take = 0;\n            if (weight[i] &lt;= wt) take = value[i] + prev[wt-weight[i]];\n\n            prev[wt] = max(take, notTake);\n        }\n    }\n\n    return prev[maxWeight];\n}\n</code></pre>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * wt)</code></li> <li>Space Complexity: <code>O(wt)</code></li> </ul>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/0-1-knapsack_920542</li> </ul>"},{"location":"DSA/DP/19%29%200%201%20Knapsack/#tags","title":"Tags","text":""},{"location":"DSA/DP/19%29%200%201%20Knapsack/#dp-recursion-knapsack-maximization","title":"dp #recursion #knapsack #maximization","text":""},{"location":"DSA/DP/2%29%20Count%20ways%20to%20reach%20Nth%20stair/","title":"2) Count ways to reach Nth stair","text":""},{"location":"DSA/DP/2%29%20Count%20ways%20to%20reach%20Nth%20stair/#description","title":"Description","text":"<ul> <li>Count no. of ways to reach nth stair from 0th stair by jumping 1 or 2 stairs at a time.</li> <li>Solution same as 1st question.</li> </ul>"},{"location":"DSA/DP/2%29%20Count%20ways%20to%20reach%20Nth%20stair/#tags","title":"Tags","text":""},{"location":"DSA/DP/2%29%20Count%20ways%20to%20reach%20Nth%20stair/#recursion-dp-fibonacci","title":"recursion #dp #fibonacci","text":""},{"location":"DSA/DP/20%29%20Minimum%20Coins/","title":"20) Minimum Coins","text":""},{"location":"DSA/DP/20%29%20Minimum%20Coins/#description","title":"Description","text":"<ul> <li>Take minimum coins from the available denominations that sum to target.</li> </ul>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/20%29%20Minimum%20Coins/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, int tar, vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        if (tar % num[0] == 0) return tar / num[0];\n        return 1e9;\n    }\n\n    if (dp[ind][tar] != -1) return dp[ind][tar];\n\n    int notTake = solve(ind-1, tar, num, dp);\n    int take = 1e9;\n    if (num[ind] &lt;= tar) take = 1 + solve(ind, tar-num[ind], num, dp);\n\n    return dp[ind][tar] = min(take, notTake);\n}\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (x+1, -1));\n\n    int ans = solve(n-1, x, num, dp);\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (x+1, 0));\n\n    // base-case\n    for (int tar=0; tar&lt;=x; tar++) {\n        if (tar % num[0] == 0) dp[0][tar] = tar / num[0];\n        else dp[0][tar] = 1e9;\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=x; tar++) {\n            int notTake = dp[i-1][tar];\n            int take = 1e9;\n            if (num[i] &lt;= tar) take = 1 + dp[i][tar-num[i]];\n\n            dp[i][tar] = min(take, notTake);\n        }\n    }\n\n    int ans = dp[n-1][x];\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint minimumElements(vector&lt;int&gt; &amp;num, int x) {\n    int n = num.size();\n    vector&lt;int&gt; prev(x+1, 0), curr(x+1, 0);\n\n    // base-case\n    for (int tar=0; tar&lt;=x; tar++) {\n        if (tar % num[0] == 0) prev[tar] = tar / num[0];\n        else prev[tar] = 1e9;\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=x; tar++) {\n            int notTake = prev[tar];\n            int take = 1e9;\n            if (num[i] &lt;= tar) take = 1 + curr[tar-num[i]];\n\n            curr[tar] = min(take, notTake);\n        }\n        prev = curr;\n    }\n\n    int ans = prev[x];\n    return ans &gt;= 1e9 ? -1: ans;\n}\n</code></pre>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-elements_3843091 </li> </ul>"},{"location":"DSA/DP/20%29%20Minimum%20Coins/#tags","title":"Tags","text":""},{"location":"DSA/DP/20%29%20Minimum%20Coins/#dp-recursion-take-not-take-minimization","title":"dp #recursion #take-not-take #minimization","text":""},{"location":"DSA/DP/21%29%20Target%20Sum/","title":"21) Target Sum","text":""},{"location":"DSA/DP/21%29%20Target%20Sum/#description","title":"Description","text":"<ul> <li>Either you can add the number or subtract at a particular index.</li> <li>Make that equal to target sum.</li> <li>Same as 18th question.</li> </ul>"},{"location":"DSA/DP/21%29%20Target%20Sum/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/target-sum_4127362</li> </ul>"},{"location":"DSA/DP/21%29%20Target%20Sum/#tags","title":"Tags","text":""},{"location":"DSA/DP/21%29%20Target%20Sum/#dp-recursion-sum-subset-sum-subsequence","title":"dp #recursion #sum #subset-sum #subsequence","text":""},{"location":"DSA/DP/22%29%20Coin%20Change%202/","title":"22) Coin Change 2","text":""},{"location":"DSA/DP/22%29%20Coin%20Change%202/#description","title":"Description","text":"<ul> <li>Count total ways to make coins sum equal to Target</li> <li>Duplicate coins allowed</li> </ul>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/22%29%20Coin%20Change%202/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong solve(int ind, int sum, int *denominations, int n, vector&lt;vector&lt;long&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        return (sum % denominations[0] == 0);\n    }\n\n    if (dp[ind][sum] != -1) return dp[ind][sum];\n\n    long notTake = solve(ind-1, sum, denominations, n, dp);\n    long take = 0;\n    if (denominations[ind] &lt;= sum) take = solve(ind, sum - denominations[ind], denominations, n, dp);\n\n    return dp[ind][sum] = take + notTake;\n}\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (value + 1, -1));\n\n    return solve(n-1, value, denominations, n, dp);\n}\n</code></pre>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (value + 1, 0));\n\n    for (int i=0; i&lt;=value; i++) {\n        dp[0][i] = (value % denominations[0] == 0);\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int tar=0; tar&lt;=value; tar++) {\n            long notTake = dp[i-1][tar];\n            long take = 0;\n            if (denominations[i] &lt;= tar) take = dp[i][tar - denominations[i]];\n\n            dp[i][tar] = take + notTake;\n        }\n    }\n\n    return dp[n-1][value];\n}\n</code></pre>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nlong countWaysToMakeChange(int *denominations, int n, int value) {\n    vector&lt;long&gt; dp(value + 1, 0);\n\n    for (int i=0; i&lt;=value; i++) {\n        dp[i] = (value % denominations[0] == 0);\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        vector&lt;long&gt; curr(value + 1, 0);\n        for (int tar=0; tar&lt;=value; tar++) {\n            long notTake = dp[tar];\n            long take = 0;\n            if (denominations[i] &lt;= tar) take = curr[tar - denominations[i]];\n\n            curr[tar] = take + notTake;\n        }\n\n        dp = curr;\n    }\n\n    return dp[value];\n}\n</code></pre>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ways-to-make-coin-change_630471</li> </ul>"},{"location":"DSA/DP/22%29%20Coin%20Change%202/#tags","title":"Tags","text":""},{"location":"DSA/DP/22%29%20Coin%20Change%202/#dp-recursion-take-not-take-count","title":"dp #recursion #take-not-take #count","text":""},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/","title":"23) Unbounded Knapsack","text":""},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#description","title":"Description","text":"<ul> <li>Allowed to take one of the sack multiple times</li> </ul>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint solve(int i, int rem, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0) {\n        return profit[0] * (rem / weight[i]);\n    }\n\n    if (dp[i][rem] != -1) return dp[i][rem];\n\n    int notTake = solve(i-1, rem, profit, weight, dp);\n    int take = 0;\n    if (weight[i] &lt;= rem) {\n        take = profit[i] + solve(i, rem - weight[i], profit, weight, dp);\n    }\n\n    return dp[i][rem] = max(take, notTake);\n}\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (w + 1, -1));\n\n    return solve(n-1, w, profit, weight, dp);\n}\n</code></pre>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target) + O(n)</code></li> </ul>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (w + 1, 0));\n\n    for (int i=0; i&lt;=w; i++) {\n        dp[0][w] = (w / weight[0]) * profit[0];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int rem=0; rem&lt;=w; rem++) {\n            int notTake = dp[i-1][rem];\n            int take = 0;\n            if (weight[i] &lt;= rem) take = profit[i] + dp[i][rem - weight[i]];\n\n            dp[i][rem] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][w];\n}\n</code></pre>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(n * target)</code></li> </ul>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint unboundedKnapsack(int n, int w, vector&lt;int&gt; &amp;profit, vector&lt;int&gt; &amp;weight){\n    vector&lt;int&gt; prev(w+1, 0), curr(w+1, 0);\n\n    for (int i=0; i&lt;=w; i++) {\n        prev[w] = (w / weight[0]) * profit[0];\n    }\n\n    for (int i=1; i&lt;n; i++) {\n        for (int rem=0; rem&lt;=w; rem++) {\n            int notTake = prev[rem];\n            int take = 0;\n            if (weight[i] &lt;= rem) take = profit[i] + curr[rem - weight[i]];\n\n            curr[rem] = max(take, notTake);\n        }\n\n        prev = curr;\n    }\n\n    return prev[w];\n}\n</code></pre>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * target)</code></li> <li>Space Complexity: <code>O(target)</code></li> </ul>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/unbounded-knapsack_1215029</li> </ul>"},{"location":"DSA/DP/23%29%20Unbounded%20Knapsack/#tags","title":"Tags","text":""},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/","title":"24) Rod Cutting Problem","text":""},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#description","title":"Description","text":"<ul> <li>Cut the rod into pieces maximizing the profit.</li> </ul>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#1-memorization","title":"1) Memorization","text":"<pre><code>int solve(int ind, int remRod, vector&lt;int&gt; &amp;price, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == 0) {\n        return price[0] * remRod;\n    }\n\n    if (dp[ind][remRod] != -1) return dp[ind][remRod];\n\n    int notTake = solve(ind-1, remRod, price, dp);\n\n    int take = 0;\n    if (remRod &gt;= ind+1) {\n        take = price[ind] + solve(ind, remRod - ind - 1, price, dp);\n    }\n\n    return dp[ind][remRod] = max(take, notTake);\n}\n\nint cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n+1, -1));\n\n    return solve(n-1, n, price, dp);\n}\n</code></pre>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n+1, 0));\n\n    for (int remRod=0; remRod&lt;=n; remRod++) {\n        dp[0][remRod] = price[0] * remRod;\n    }\n\n    for (int ind=1; ind&lt;n; ind++) {\n        for (int remRod=0; remRod&lt;=n; remRod++) {\n            int notTake = dp[ind-1][remRod];\n\n            int take = 0;\n            if (remRod &gt;= ind+1) {\n                take = price[ind] + dp[ind][remRod - ind - 1];\n            }\n\n            dp[ind][remRod] = max(take, notTake);\n        }\n    }\n\n    return dp[n-1][n];\n}\n</code></pre>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n * n)</code></li> </ul>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int cutRod(vector&lt;int&gt; &amp;price, int n)\n{\n    // Write your code here.\n    vector&lt;int&gt; curr(n+1, 0), prev(n+1, 0);\n\n    for (int remRod=0; remRod&lt;=n; remRod++) {\n        prev[remRod] = price[0] * remRod;\n    }\n\n    for (int ind=1; ind&lt;n; ind++) {\n        for (int remRod=0; remRod&lt;=n; remRod++) {\n            int notTake = prev[remRod];\n\n            int take = 0;\n            if (remRod &gt;= ind+1) {\n                take = price[ind] + curr[remRod - ind - 1];\n            }\n\n            curr[remRod] = max(take, notTake);\n        }\n\n        prev = curr;\n    }\n\n    return prev[n];\n}\n</code></pre>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/rod-cutting-problem_800284</li> </ul>"},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#tags","title":"Tags","text":""},{"location":"DSA/DP/24%29%20Rod%20Cutting%20Problem/#dp-recursion-take-not-take-maximization","title":"dp #recursion #take-not-take #maximization","text":""},{"location":"DSA/DP/25%29%20LCS/","title":"25) LCS","text":""},{"location":"DSA/DP/25%29%20LCS/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/25%29%20LCS/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == -1 || j == -1) {\n        return 0;\n    }\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    if (s[i] == t[j]) return dp[i][j] = 1 + solve(i-1, j-1, s, t, dp);\n\n    return dp[i][j] = max(solve(i-1, j, s, t, dp), solve(i, j-1, s, t, dp));\n}\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n    return solve(n-1, m-1, s, t, dp);\n}\n</code></pre>"},{"location":"DSA/DP/25%29%20LCS/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/25%29%20LCS/#notes","title":"Notes","text":"<ul> <li>Match-NotMatch technique</li> <li>Check if it matches on index</li> <li>Else take optimized of reduced index by 1 differently</li> </ul>"},{"location":"DSA/DP/25%29%20LCS/#2-tabulation","title":"2) Tabulation","text":"<ul> <li>Uses shifted DP, because -1 index base case is not possible.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 || j == 0) {\n        return 0;\n    }\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    if (s[i-1] == t[j-1]) return dp[i][j] = 1 + solve(i-1, j-1, s, t, dp);\n\n    return dp[i][j] = max(solve(i-1, j, s, t, dp), solve(i, j-1, s, t, dp));\n}\n\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n</code></pre>"},{"location":"DSA/DP/25%29%20LCS/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/25%29%20LCS/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n</code></pre>"},{"location":"DSA/DP/25%29%20LCS/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/25%29%20LCS/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-common-subsequence_624879</li> </ul>"},{"location":"DSA/DP/25%29%20LCS/#tags","title":"Tags","text":""},{"location":"DSA/DP/25%29%20LCS/#dp-recursion-lcs-match-notmatch-strings","title":"dp #recursion #lcs #match-notMatch #strings","text":""},{"location":"DSA/DP/26%29%20Print%20LCS/","title":"26) Print LCS","text":""},{"location":"DSA/DP/26%29%20Print%20LCS/#description","title":"Description","text":"<ul> <li>Use DP table of max LCS to solve this.</li> </ul>"},{"location":"DSA/DP/26%29%20Print%20LCS/#solution","title":"Solution","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nstring findLCS(int n, int m, string &amp;s, string &amp;t){\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    string ans = \"\";\n    int ansLen = dp[n][m];\n    for (int i=0; i&lt;ansLen; i++) ans += '$';\n\n    int ind = ansLen-1, i = n, j = m;\n\n    while (i &gt; 0 &amp;&amp; j &gt; 0) {\n        if (s[i-1] == t[j-1]) {\n            ans[ind--] = s[i-1];\n            i--;\n            j--;\n        }\n        else if (dp[i][j-1] &gt;= dp[i-1][j]) {\n            j--;\n        } \n        else {\n            i--;\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/26%29%20Print%20LCS/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/26%29%20Print%20LCS/#notes","title":"Notes","text":"<p>![[Pasted image 20260102191619.png]]</p>"},{"location":"DSA/DP/26%29%20Print%20LCS/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/print-longest-common-subsequence_8416383</li> </ul>"},{"location":"DSA/DP/26%29%20Print%20LCS/#tags","title":"Tags","text":""},{"location":"DSA/DP/26%29%20Print%20LCS/#dp-recursion-match-notmatch-strings-lcs","title":"dp #recursion #match-notMatch #strings #lcs","text":""},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/","title":"27) Longest Common Substring","text":""},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#description","title":"Description","text":"<ul> <li>Minor change in LCS - If not match, it is 0.</li> <li>Return max len in the DP Table</li> </ul>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#1-tabulation","title":"1) Tabulation","text":"<pre><code>int lcs(string &amp;s, string &amp;t){\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    int ans = 0;\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n                ans = max(ans, dp[i][j]);\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#notes","title":"Notes","text":""},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#2-space-optimization","title":"2) Space Optimization","text":"<pre><code>int lcs(string &amp;s, string &amp;t){\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    int ans = 0;\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n                ans = max(ans, curr[j]);\n            } else {\n                curr[j] = 0;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#notes_1","title":"Notes","text":"<p>![[Pasted image 20260102194358.png]]</p>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-common-substring_1235207</li> </ul>"},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#tags","title":"Tags","text":""},{"location":"DSA/DP/27%29%20Longest%20Common%20Substring/#dp-recursion-lcs-match-notmatch-strings","title":"dp #recursion #lcs #match-notMatch #strings","text":""},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/","title":"28) Longest Palindromic Subsequence","text":""},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#description","title":"Description","text":"<ul> <li><code>lcs(s, rev(s))</code> is answer</li> </ul>"},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\nint longestPalindromeSubsequence(string s)\n{\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n\n    return lcs(s, rev);\n}\n</code></pre>"},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/longest-palindromic-subsequence_842787</li> </ul>"},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#tags","title":"Tags","text":""},{"location":"DSA/DP/28%29%20Longest%20Palindromic%20Subsequence/#dp-recursion-lcs-match-notmatch-strings","title":"dp #recursion #lcs #match-notMatch #strings","text":""},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/","title":"29) Minimum Insertions to make string palindrome","text":""},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#description","title":"Description","text":"<ul> <li><code>len(s) - lps(s)</code></li> </ul>"},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\nint longestPalindromeSubsequence(string s)\n{\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n\n    return lcs(s, rev);\n}\n\nint minimumInsertions(string &amp;str)\n{\n    return str.size() - longestPalindromeSubsequence(str);\n}\n</code></pre>"},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-insertions-to-make-a-string-palindrome_985293</li> </ul>"},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#tags","title":"Tags","text":""},{"location":"DSA/DP/29%29%20Minimum%20Insertions%20to%20make%20string%20palindrome/#dp-recursion-match-notmatch-strings-lcs","title":"dp #recursion #match-notMatch #strings #lcs","text":""},{"location":"DSA/DP/3%29%20Frog%20Jump/","title":"3) Frog Jump","text":""},{"location":"DSA/DP/3%29%20Frog%20Jump/#description","title":"Description","text":"<ul> <li>Frog can jump from one building to other with the energy of abs(heights[i] - heights[j]).</li> <li>Frog can jump 1 or 2 buildings at a time.</li> <li>Find minimum energy to go from 1st to Nth building.</li> </ul>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/3%29%20Frog%20Jump/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, vector&lt;int&gt; &amp;heights, vector&lt;int&gt; &amp;dp) {\n    if (ind == 0) return 0;\n\n    if (dp[ind] != -1) return dp[ind];\n\n    int left = solve(ind - 1, heights, dp) + abs(heights[ind] - heights[ind - 1]);\n\n    int right = INT_MAX;\n    if (ind &gt; 1) right = solve(ind - 2, heights, dp) + abs(heights[ind] - heights[ind - 2]);\n\n    return dp[ind] = min(left, right);\n}\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n, -1);\n    return solve(n - 1, heights, dp);\n}\n</code></pre>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n);\n    dp[0] = 0;\n\n    for (int i=1; i&lt;n; i++) {\n        int fs = dp[i-1] + abs(heights[i] - heights[i-1]);\n        int ss = INT_MAX;\n        if (i &gt; 1) ss = dp[i-2] + abs(heights[i] - heights[i - 2]);\n\n        dp[i] = min(fs, ss);\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, vector&lt;int&gt; &amp;heights)\n{\n    int prev2 = 0, prev = 0;\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int fs = prev + abs(heights[i] - heights[i-1]);\n        int ss = INT_MAX;\n        if (i &gt; 1) ss = prev2 + abs(heights[i] - heights[i - 2]);\n\n        curr = min(fs, ss);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return curr;\n}\n</code></pre>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/frog-jump_3621012</li> </ul>"},{"location":"DSA/DP/3%29%20Frog%20Jump/#tags","title":"Tags","text":""},{"location":"DSA/DP/3%29%20Frog%20Jump/#dp-recursion","title":"dp #recursion","text":""},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/","title":"30) Minimum Insertions or Deletions to Convert String A to String B","text":""},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#description","title":"Description","text":"<p><code>int deletions = s1.size() - lcs(s1, s2);</code>int insertions = s2.size() - lcs(s1, s2);<code></code>return deletions + insertions;</p>"},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint lcs(string s, string t) {\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n    for (int i=0; i&lt;m; i++) {\n        prev[i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                curr[j] = 1 + prev[j-1];\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n\n        prev = curr;\n    }\n\n    return prev[m];\n}\n\n\nint canYouMake(string &amp;s1, string &amp;s2){\n    int deletions = s1.size() - lcs(s1, s2);\n    int insertions = s2.size() - lcs(s1, s2);\n\n    return deletions + insertions;\n}\n</code></pre>"},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/minimum-number-of-deletions-and-insertions_4244510</li> </ul>"},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#tags","title":"Tags","text":""},{"location":"DSA/DP/30%29%20Minimum%20Insertions%20or%20Deletions%20to%20Convert%20String%20A%20to%20String%20B/#dp-recursion-match-notmatch-strings-lcs","title":"dp #recursion #match-notMatch #strings #lcs","text":""},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/","title":"31) Shortest Common Supersequence","text":""},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#description","title":"Description","text":"<ul> <li><code>n + m - lcs(s, t)</code></li> <li>Construct string from DP table</li> </ul>"},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#1-tabulation","title":"1) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \nstring shortestSupersequence(string s, string t)\n{\n    int n = s.size();\n    int m = t.size();\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n    for (int i=0; i&lt;=n; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i=0; i&lt;=m; i++) {\n        dp[0][i] = 0;\n    }\n\n    for (int i=1; i&lt;=n; i++) {\n        for (int j=1; j&lt;=m; j++) {\n            if (s[i-1] == t[j-1]) {\n                dp[i][j] = 1 + dp[i-1][j-1];\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    string ans = \"\";\n\n    int i = n, j = m;\n\n    while (i &gt; 0 &amp;&amp; j &gt; 0) {\n        if (s[i-1] == t[j-1]) {\n            ans += s[i-1];\n            i--;\n            j--;\n        }\n        else if (dp[i][j-1] &gt;= dp[i-1][j]) {\n            ans += t[j-1];\n            j--;\n        } \n        else {\n            ans += s[i-1];\n            i--;\n        }\n    }\n\n    while (i &gt; 0) {\n        ans += s[i-1];\n        i--;\n    }\n\n\n    while (j &gt; 0) {\n        ans += t[j-1];\n        j--;\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    return ans;\n}\n</code></pre>"},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#notes","title":"Notes","text":"<p>![[Pasted image 20260102205908.png]] ![[Pasted image 20260102205932.png]]</p>"},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/shortest-supersequence_4244493</li> </ul>"},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#tags","title":"Tags","text":""},{"location":"DSA/DP/31%29%20Shortest%20Common%20Supersequence/#dp-recursion-match-notmatch-strings-lcs","title":"dp #recursion #match-notMatch #strings #lcs","text":""},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/","title":"32) Distinct Subsequences","text":""},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#description","title":"Description","text":"<ul> <li>Find no. of distinct subsequences of s which equals t</li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == -1) return 1;\n\n        if (i == -1) return 0;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i] == t[j]) {\n            return dp[i][j] = solve(i-1, j-1, s, t, dp) + solve(i-1, j, s, t, dp);\n        }\n\n        return dp[i][j] = solve(i-1, j, s, t, dp);\n    }\n\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1)); \n        return solve(n-1, m-1, s, t, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n\n    // for reference - shifted arrays\n    int solve(int i, int j, string &amp;s, string &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == 0) return 1;\n\n        if (i == 0) return 0;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i-1] == t[j-1]) {\n            return dp[i][j] = solve(i-1, j-1, s, t, dp) + solve(i-1, j, s, t, dp);\n        }\n\n        return dp[i][j] = solve(i-1, j, s, t, dp);\n    }\n\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n\n        for (int i=0; i&lt;=n; i++) {\n            dp[i][0] = 1;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == t[j-1]) {\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n\n        return (int)dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n        vector&lt;unsigned long long&gt; prev(m+1, 0), curr(m+1, 0);\n\n        prev[0] = curr[0] = 1;\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == t[j-1]) {\n                    curr[j] = prev[j-1] + prev[j];\n                } else {\n                    curr[j] = prev[j];\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#3-space-optimization-1d","title":"3) Space Optimization - 1D","text":"<pre><code>class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int n = s.size();\n        int m = t.size();\n        vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n+1, vector&lt;unsigned long long&gt; (m+1, 0));\n        vector&lt;unsigned long long&gt; prev(m+1, 0);\n\n        prev[0] = 1;\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=m; j&gt;=1; j--) {\n                if (s[i-1] == t[j-1]) {\n                    prev[j] = prev[j-1] + prev[j];\n                } else {\n                    prev[j] = prev[j];\n                }\n            }\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/distinct-subsequences/</li> </ul>"},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#tags","title":"Tags","text":""},{"location":"DSA/DP/32%29%20Distinct%20Subsequences/#dp-recursion-strings","title":"dp #recursion #strings","text":""},{"location":"DSA/DP/33%29%20Edit%20Distance/","title":"33) Edit Distance","text":""},{"location":"DSA/DP/33%29%20Edit%20Distance/#description","title":"Description","text":"<ul> <li>Insert, Delete or replace in str1 to make it equal to str2</li> <li>Return min operations</li> </ul>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/33%29%20Edit%20Distance/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;word1, string &amp;word2, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == -1) return i + 1;\n\n        if (i == -1) return j + 1;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (word1[i] == word2[j]) return dp[i][j] = solve(i-1, j-1, word1, word2, dp);\n\n        return dp[i][j] = 1 + min({\n            solve(i-1, j-1, word1, word2, dp), \n            solve(i, j-1, word1, word2, dp), \n            solve(i-1, j, word1, word2, dp)\n        });\n    }\n\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n        return solve(n-1, m-1, word1, word2, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n+m)</code></li> </ul>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    int solve(int i, int j, string &amp;word1, string &amp;word2, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (j == 0) return i;\n\n        if (i == 0) return j;\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (word1[i-1] == word2[j-1]) return dp[i][j] = solve(i-1, j-1, word1, word2, dp);\n\n        return dp[i][j] = 1 + min({\n            solve(i-1, j-1, word1, word2, dp), \n            solve(i, j-1, word1, word2, dp), \n            solve(i-1, j, word1, word2, dp)\n        });\n    }\n\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (m+1, 0));\n\n        for (int i=0; i&lt;=n; i++) {\n            dp[i][0] = i;\n        }\n\n        for (int j=0; j&lt;=m; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                }\n                else {\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n\n        vector&lt;int&gt; prev(m+1, 0), curr(m+1, 0);\n\n        for (int i=0; i&lt;=m; i++) {\n            prev[i] = i;\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            curr[0] = i;\n            for (int j=1; j&lt;=m; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    curr[j] = prev[j-1];\n                }\n                else {\n                    curr[j] = 1 + min({prev[j-1], curr[j-1], prev[j]});\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/edit-distance/</li> </ul>"},{"location":"DSA/DP/33%29%20Edit%20Distance/#tags","title":"Tags","text":""},{"location":"DSA/DP/33%29%20Edit%20Distance/#dp-recursion-strings","title":"dp #recursion #strings","text":""},{"location":"DSA/DP/34%29%20Wildcard%20Matching/","title":"34) Wildcard Matching","text":""},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#description","title":"Description","text":"<ul> <li>Match string pattern with string str.</li> <li>patterns contains ? or * or letters</li> <li> <ul> <li>means any string (0 or more letters)</li> </ul> </li> <li>? means single letter</li> </ul>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n\n    bool solve(int i, int j, string &amp;s, string &amp;p, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (i == -1 &amp;&amp; j == -1) return true;\n\n        if (j == -1) return false;\n\n        if (i == -1) {\n            for (int k=0; k&lt;=j; k++) {\n                if (p[k] != '*') return false;\n            }\n\n            return true;\n        }\n\n        if (dp[i][j] != -1) return dp[i][j];\n\n        if (s[i] == p[j] || p[j] == '?') {\n            return dp[i][j] = solve(i-1, j-1, s, p, dp);\n        }\n\n        if (p[j] == '*') {\n            return dp[i][j] = solve(i, j-1, s, p, dp) | solve(i-1, j, s, p, dp);\n        }\n\n        return dp[i][j] = false;\n    }\n\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n        return solve(n-1, m-1, s, p, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m) + O(n + m)</code></li> </ul>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;vector&lt;bool&gt;&gt; dp(n+1, vector&lt;bool&gt; (m+1, false));\n\n        dp[0][0] = true;\n\n        for (int i=1; i&lt;=n; i++) {\n            dp[i][0] = false;\n        }\n\n        for (int j=1; j&lt;=m; j++) {\n            dp[0][j] = p[j-1] == '*' &amp;&amp; dp[0][j-1];\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == p[j-1] || p[j-1] == '?') {\n                    dp[i][j] = dp[i-1][j-1];\n                } else if (p[j-1] == '*') {\n                    dp[i][j] = dp[i][j-1] | dp[i-1][j];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(n * m)</code></li> </ul>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n\n        vector&lt;bool&gt; prev(m+1, false), curr(m+1, false);\n\n        prev[0] = true;\n\n        for (int j=1; j&lt;=m; j++) {\n            prev[j] = p[j-1] == '*' &amp;&amp; prev[j-1];\n        }\n\n        for (int i=1; i&lt;=n; i++) {\n            for (int j=1; j&lt;=m; j++) {\n                if (s[i-1] == p[j-1] || p[j-1] == '?') {\n                    curr[j] = prev[j-1];\n                } else if (p[j-1] == '*') {\n                    curr[j] = curr[j-1] | prev[j];\n                } else {\n                    curr[j] = false;\n                }\n            }\n\n            prev = curr;\n        }\n\n        return prev[m];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * m)</code></li> <li>Space Complexity: <code>O(m)</code></li> </ul>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/wildcard-matching/</li> </ul>"},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#tags","title":"Tags","text":""},{"location":"DSA/DP/34%29%20Wildcard%20Matching/#dp-recursion-strings","title":"dp #recursion #strings","text":""},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/","title":"35) Best Time to Buy and Sell Stock","text":""},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#description","title":"Description","text":"<ul> <li>Can be traded only once.</li> </ul>"},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#solutions","title":"Solutions","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \nint maximumProfit(vector&lt;int&gt; &amp;prices){\n    int mini = prices[0], profit = 0;\n\n    for (int i=1; i&lt;prices.size(); i++) {\n        profit = max(profit, prices[i] - mini);\n        mini = min(mini, prices[i]);\n    }\n\n    return profit;\n}\n</code></pre>"},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/stocks-are-profitable_893405</li> </ul>"},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#tags","title":"Tags","text":""},{"location":"DSA/DP/35%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#dp-stocks","title":"dp #stocks","text":""},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/","title":"36) Best Time to Buy and Sell Stock   II","text":""},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#description","title":"Description","text":"<ul> <li>Can be traded multiple times.</li> </ul>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint N;\n\nlong solve(int ind, int buyAllowed, long *values, vector&lt;vector&lt;long&gt;&gt; &amp;dp) {\n    if (ind == N) return 0;\n\n    if (dp[ind][buyAllowed] != -1) return dp[ind][buyAllowed];\n\n    if (buyAllowed == 0) {\n        long sell = values[ind] + solve(ind+1, 1, values, dp);\n        long notSell = solve(ind+1, 0, values, dp);\n\n        return dp[ind][buyAllowed] = max(sell, notSell);\n    }\n    else {\n        long buy = -values[ind] + solve(ind+1, 0, values, dp);\n        long notBuy = solve(ind+1, 1, values, dp);\n        return dp[ind][buyAllowed] = max(buy, notBuy);\n    }\n}\n\nlong getMaximumProfit(long *values, int n)\n{\n    N = n;\n    vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt; (2, -1));\n\n    return solve(0, 1, values, dp);\n}\n</code></pre>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2) + O(n)</code></li> </ul>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nlong getMaximumProfit(long *values, int n)\n{\n    vector&lt;vector&lt;long&gt;&gt; dp(n+1, vector&lt;long&gt; (2, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -values[ind] + dp[ind+1][0];\n        long notBuy = dp[ind+1][1];\n\n        dp[ind][1] = max(buy, notBuy);\n\n        long sell = values[ind] + dp[ind+1][1];\n        long notSell = dp[ind+1][0];\n\n        dp[ind][0] = max(sell, notSell);\n    }\n\n    return dp[0][1];\n}\n</code></pre>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2)</code></li> </ul>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nlong getMaximumProfit(long *values, int n)\n{\n    vector&lt;long&gt; ahead(2, 0), curr(2, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -values[ind] + ahead[0];\n        long notBuy = ahead[1];\n\n        curr[1] = max(buy, notBuy);\n\n        long sell = values[ind] + ahead[1];\n        long notSell = ahead[0];\n\n        curr[0] = max(sell, notSell);\n\n        ahead = curr;\n    }\n\n    return ahead[1];\n}\n</code></pre>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-ii_630282</li> </ul>"},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#tags","title":"Tags","text":""},{"location":"DSA/DP/36%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20II/#dp-recursion-stocks","title":"dp #recursion #stocks","text":""},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/","title":"37) Best Time to Buy and Sell Stock   III","text":""},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#description","title":"Description","text":"<ul> <li>Can be traded only 2 times maximum.</li> </ul>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#1-memorization","title":"1) Memorization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint solve(int ind, int buyAllowed, int rem, vector&lt;int&gt; &amp;prices, int &amp;n, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; &amp;dp) {\n    if (ind == n || rem == 0) return 0;\n\n    if (dp[ind][buyAllowed][rem] != -1) return dp[ind][buyAllowed][rem];\n\n    if (buyAllowed) {\n        int buy = -prices[ind] + solve(ind+1, 0, rem, prices, n, dp);\n        int notBuy = solve(ind+1, 1, rem, prices, n, dp);\n\n        return dp[ind][buyAllowed][rem] = max(buy, notBuy);\n    } \n    else {\n        int sell = prices[ind] + solve(ind+1, 1, rem-1, prices, n, dp);\n        int notSell = solve(ind+1, 0, rem, prices, n, dp);\n\n        return dp[ind][buyAllowed][rem] = max(sell, notSell);\n    }\n}\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;int&gt;&gt; (2, vector&lt;int&gt; (3, -1)));\n\n    return solve(0, 1, 2, prices, n, dp);\n}\n</code></pre>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(n * 2 * 3) + O(n)</code></li> </ul>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;int&gt;&gt; (2, vector&lt;int&gt; (3, 0)));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=2; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + dp[ind+1][0][rem];\n                    int notBuy = dp[ind+1][1][rem];\n\n                    dp[ind][buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + dp[ind+1][1][rem-1];\n                    int notSell = dp[ind+1][0][rem];\n\n                    dp[ind][buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n    }\n\n    return dp[0][1][2];\n}\n</code></pre>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(n * 2 * 3)</code></li> </ul>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maxProfit(vector&lt;int&gt;&amp; prices)\n{\n    int n = prices.size();\n    vector&lt;vector&lt;int&gt;&gt; ahead(2, vector&lt;int&gt; (3, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(2, vector&lt;int&gt; (3, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=2; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + ahead[0][rem];\n                    int notBuy = ahead[1][rem];\n\n                    curr[buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + ahead[1][rem-1];\n                    int notSell = ahead[0][rem];\n\n                    curr[buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n\n        ahead = curr;\n    }\n\n    return ahead[1][2];\n}\n</code></pre>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * 3)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-iii_1071012</li> </ul>"},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#tags","title":"Tags","text":""},{"location":"DSA/DP/37%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20III/#dp-recursion-stocks","title":"dp #recursion #stocks","text":""},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/","title":"38) Best Time to Buy and Sell Stock   IV","text":""},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#description","title":"Description","text":"<ul> <li>Allowed at most K transactions.</li> <li>Same as 37.</li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; ahead(2, vector&lt;int&gt; (k+1, 0));\n    vector&lt;vector&lt;int&gt;&gt; curr(2, vector&lt;int&gt; (k+1, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int buyAllowed=0; buyAllowed&lt;=1; buyAllowed++) {\n            for (int rem=1; rem&lt;=k; rem++) {\n                if (buyAllowed) {\n                    int buy = -prices[ind] + ahead[0][rem];\n                    int notBuy = ahead[1][rem];\n\n                    curr[buyAllowed][rem] = max(buy, notBuy);\n                } \n                else {\n                    int sell = prices[ind] + ahead[1][rem-1];\n                    int notSell = ahead[0][rem];\n\n                    curr[buyAllowed][rem] = max(sell, notSell);\n                }\n            }\n        }\n\n        ahead = curr;\n    }\n\n    return ahead[1][k];\n}\n</code></pre>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#another-approach-transaction-method","title":"Another Approach (Transaction Method)","text":"<ul> <li>Even transaction no. means BUY, odd means SELL</li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#1-memoization","title":"1) Memoization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint solve(int ind, int tranNo, vector&lt;int&gt; &amp;prices, int &amp;n, int &amp;k, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (ind == n || tranNo == 2*k) return 0;\n\n    if (dp[ind][tranNo] != -1) return dp[ind][tranNo];\n\n    // buy\n    if (tranNo % 2 == 0) {\n        return dp[ind][tranNo] = max(-prices[ind] + solve(ind+1, tranNo+1, prices, n, k, dp),\n                                solve(ind+1, tranNo, prices, n, k, dp));\n    }\n    else {\n        return dp[ind][tranNo] = max(prices[ind] + solve(ind+1, tranNo+1, prices, n, k, dp),\n                                solve(ind+1, tranNo, prices, n, k, dp));\n    }\n}\n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (2*k, -1));\n    return solve(0, 0, prices, n, k, dp);\n}\n</code></pre>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(n * 2 * k) + O(n)</code></li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (2*k+1, 0));\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int tranNo=0; tranNo&lt;=2*k-1; tranNo++) {\n            if (tranNo % 2 == 0) {\n                dp[ind][tranNo] = max(-prices[ind] + dp[ind+1][tranNo+1], dp[ind+1][tranNo]);\n            }\n            else {\n                dp[ind][tranNo] = max(prices[ind] + dp[ind+1][tranNo+1], dp[ind+1][tranNo]);\n            }\n        }\n    }\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(n * 2 * k)</code></li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int k)\n{\n    vector&lt;int&gt; ahead(2*k+1, 0), curr(2*k+1, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        for (int tranNo=0; tranNo&lt;=2*k-1; tranNo++) {\n            if (tranNo % 2 == 0) {\n                curr[tranNo] = max(-prices[ind] + ahead[tranNo+1], ahead[tranNo]);\n            }\n            else {\n                curr[tranNo] = max(prices[ind] + ahead[tranNo+1], ahead[tranNo]);\n            }\n        }\n\n        ahead = curr;\n    }\n    return ahead[0];\n}\n</code></pre>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2 * k)</code></li> <li>Space Complexity: <code>O(k)</code></li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock_1080698</li> </ul>"},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#tags","title":"Tags","text":""},{"location":"DSA/DP/38%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20-%20IV/#dp-recursion-stocks","title":"dp #recursion #stocks","text":""},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/","title":"39) Best Time to Buy and Sell Stock with Cooldown","text":""},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#description","title":"Description","text":"<ul> <li>After sell call omit 1 index</li> </ul>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#1-memorization","title":"1) Memorization","text":"<pre><code>class Solution {\npublic:\n\n    int solve(int ind, int buyAllowed, vector&lt;int&gt; &amp;prices, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n        if (ind &gt;= prices.size()) return 0;\n\n        if (dp[ind][buyAllowed] != -1) return dp[ind][buyAllowed];\n\n        if (buyAllowed) {\n            return dp[ind][buyAllowed] = max(\n                -prices[ind] + solve(ind+1, 0, prices, dp),\n                solve(ind+1, 1, prices, dp)\n            );\n        }\n        else {\n            return dp[ind][buyAllowed] = max(\n                prices[ind] + solve(ind+2, 1, prices, dp),\n                solve(ind+1, 0, prices, dp)\n            );\n        }\n    }\n\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (2, -1));\n        return solve(0, 1, prices, dp);\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2) + O(n)</code></li> </ul>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#2-tabulation","title":"2) Tabulation","text":"<pre><code>class Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n+2, vector&lt;int&gt; (2, 0));\n\n        for (int ind=n-1; ind&gt;=0; ind--) {\n            dp[ind][1] = max(-prices[ind] + dp[ind+1][0], dp[ind+1][1]);\n            dp[ind][0] = max(prices[ind] + dp[ind+2][1], dp[ind+1][0]);\n        }\n\n        return dp[0][1];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(n * 2)</code></li> </ul>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>class Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;int&gt; front2(2, 0);\n        vector&lt;int&gt; front1(2, 0);\n        vector&lt;int&gt; curr(2, 0);\n\n        for (int ind=n-1; ind&gt;=0; ind--) {\n            curr[1] = max(-prices[ind] + front1[0], front1[1]);\n            curr[0] = max(prices[ind] + front2[1], front1[0]);\n\n            front2 = front1;\n            front1 = curr;\n        }\n\n        return curr[1];\n    }\n};\n</code></pre>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</li> </ul>"},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#tags","title":"Tags","text":""},{"location":"DSA/DP/39%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown/#dp-recursion-stocks","title":"dp #recursion #stocks","text":""},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/","title":"4) Frog Jump (k jumps)","text":""},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/#description","title":"Description","text":"<ul> <li>Here, k jumps are allowed.</li> </ul>"},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint frogJump(int n, int k, vector&lt;int&gt; &amp;heights)\n{\n    vector&lt;int&gt; dp(n, INT_MAX);\n    dp[0] = 0;\n\n    for (int i=1; i&lt;n; i++) {\n        for (int j=1; j&lt;=k; j++) {\n            if (i-j &gt;= 0) {\n                dp[i] = min(dp[i], dp[i-j] + abs(heights[i] - heights[i-j]));\n            } else {\n                break;\n            }\n        }\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/#tags","title":"Tags","text":""},{"location":"DSA/DP/4%29%20Frog%20Jump%20%28k%20jumps%29/#recursion-dp","title":"recursion #dp","text":""},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/","title":"40) Best Time to Buy and Sell Stock with Transaction Fee","text":""},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#solution","title":"Solution","text":""},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#1-space-optimization","title":"1) Space Optimization","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\n\nint maximumProfit(vector&lt;int&gt; &amp;prices, int n, int fee)\n{\n    vector&lt;long&gt; ahead(2, 0), curr(2, 0);\n\n    for (int ind=n-1; ind&gt;=0; ind--) {\n        long buy = -prices[ind] + ahead[0];\n        long notBuy = ahead[1];\n\n        curr[1] = max(buy, notBuy);\n\n        long sell = prices[ind] - fee + ahead[1];\n        long notSell = ahead[0];\n\n        curr[0] = max(sell, notSell);\n\n        ahead = curr;\n    }\n\n    return ahead[1];\n}\n</code></pre>"},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 2)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/best-time-to-buy-and-sell-stock-with-transaction-fee_3118974</li> </ul>"},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#tags","title":"Tags","text":""},{"location":"DSA/DP/40%29%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#dp-recursion-stocks","title":"dp #recursion #stocks","text":""},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/","title":"5) Maximum Sum of Non Adjacent Elements","text":""},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint solve(int ind, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;dp) {\n    if (ind == 0) return nums[ind];\n\n    if (ind &lt; 0) return 0;\n\n    if (dp[ind] != -1) return dp[ind];\n\n    int pick = nums[ind] + solve(ind - 2, nums, dp);\n    int notPick = solve(ind - 1, nums, dp);\n\n    return dp[ind] = max(pick, notPick);\n}\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    vector&lt;int&gt; dp(n, -1);\n\n    return solve(n-1, nums, dp);\n}\n</code></pre>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n) + O(n)</code></li> </ul>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    vector&lt;int&gt; dp(n);\n    dp[0] = nums[0];\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += dp[i-2];\n\n        int notTake = dp[i-1];\n\n        dp[i] = max(take, notTake);\n    }\n\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    int prev2 = 0, prev = nums[0];\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += prev2;\n\n        int notTake = prev;\n\n        curr = max(take, notTake);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return prev;\n}\n</code></pre>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/maximum-sum-of-non-adjacent-elements_843261</li> </ul>"},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#tags","title":"Tags","text":""},{"location":"DSA/DP/5%29%20Maximum%20Sum%20of%20Non-Adjacent%20Elements/#recursion-dp-sum-maximization-take-not-take","title":"recursion #dp #sum #maximization #take-not-take","text":""},{"location":"DSA/DP/6%29%20House%20Robber%202/","title":"6) House Robber 2","text":""},{"location":"DSA/DP/6%29%20House%20Robber%202/#description","title":"Description","text":"<ul> <li>Same as 5th question but a circular array</li> </ul>"},{"location":"DSA/DP/6%29%20House%20Robber%202/#solution","title":"Solution","text":""},{"location":"DSA/DP/6%29%20House%20Robber%202/#space-optimization","title":"Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \n\nint maximumNonAdjacentSum(vector&lt;int&gt; &amp;nums){\n    int n = nums.size();\n    int prev2 = 0, prev = nums[0];\n    int curr;\n\n    for (int i=1; i&lt;n; i++) {\n        int take = nums[i];\n        if (i &gt; 1) take += prev2;\n\n        int notTake = prev;\n\n        curr = max(take, notTake);\n        prev2 = prev;\n        prev = curr;\n    }\n\n    return prev;\n}\n\nlong long int houseRobber(vector&lt;int&gt;&amp; valueInHouse)\n{\n    int n = valueInHouse.size();\n    vector&lt;int&gt; temp1, temp2;\n\n    if (n == 1) return valueInHouse[0];\n\n    for (int i=0; i&lt;n; i++) {\n        if (i != 0) temp1.push_back(valueInHouse[i]);\n        if (i != n-1) temp2.push_back(valueInHouse[i]);\n    }\n\n    return max(maximumNonAdjacentSum(temp1), maximumNonAdjacentSum(temp2));\n}\n</code></pre>"},{"location":"DSA/DP/6%29%20House%20Robber%202/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/6%29%20House%20Robber%202/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/house-robber_839733</li> </ul>"},{"location":"DSA/DP/6%29%20House%20Robber%202/#tags","title":"Tags","text":""},{"location":"DSA/DP/6%29%20House%20Robber%202/#recursion-dp-sum-circular-array-take-not-take","title":"recursion #dp #sum #circular-array #take-not-take","text":""},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/","title":"7) Ninja's Training","text":""},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#description","title":"Description","text":"<ul> <li>There is a N x 3 array of points.</li> <li>The ninja cannot earn points from the index which was taken in previous step.</li> <li>Find max points which ninja can earn.</li> </ul>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#1-memorization","title":"1) Memorization","text":"<pre><code>int solve(int day, int last, vector&lt;vector&lt;int&gt;&gt; &amp;points, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (day == 0) {\n        int maxi = 0;\n        for (int task = 0; task &lt; 3; task++) {\n            if (task != last) {\n                maxi = max(maxi, points[0][task]);\n            }\n        }\n\n        return maxi;\n    }\n\n    if (dp[day][last] != -1) return dp[day][last];\n\n    int maxi = 0;\n\n    for (int task = 0; task &lt; 3; task++) {\n        if (task != last) {\n            maxi = max(maxi, points[day][task] + solve(day - 1, task, points, dp));\n        }\n    }\n\n    return dp[day][last] = maxi;\n}\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (4, -1));\n\n    return solve(n - 1, 3, points, dp);\n}\n</code></pre>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(n) + O(n * 4)</code></li> </ul>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (4, 0));\n\n    dp[0][0] = max(points[0][1], points[0][2]);\n    dp[0][1] = max(points[0][0], points[0][2]);\n    dp[0][2] = max(points[0][0], points[0][1]);\n    dp[0][3] = max({points[0][0], points[0][1], points[0][2]});\n\n    for (int day = 1; day &lt; n; day++) {\n        for (int last = 0; last &lt; 4; last++) {\n            for (int task = 0; task &lt; 3; task++) {\n                if (task != last) {\n                    int point = points[day][task] + dp[day - 1][task];\n                    dp[day][last] = max(dp[day][last], point);\n                }\n            }\n        }\n    }\n\n    return dp[n-1][3];\n}\n</code></pre>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(n * 4)</code></li> </ul>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint ninjaTraining(int n, vector&lt;vector&lt;int&gt;&gt; &amp;points)\n{\n    vector&lt;int&gt; prev(4, 0);\n\n    prev[0] = max(points[0][1], points[0][2]);\n    prev[1] = max(points[0][0], points[0][2]);\n    prev[2] = max(points[0][0], points[0][1]);\n    prev[3] = max({points[0][0], points[0][1], points[0][2]});\n\n    for (int day = 1; day &lt; n; day++) {\n        vector&lt;int&gt; temp(4, 0);\n\n        for (int last = 0; last &lt; 4; last++) {\n            for (int task = 0; task &lt; 3; task++) {\n                if (task != last) {\n                    int point = points[day][task] + prev[task];\n                    temp[last] = max(temp[last], point);\n                }\n            }\n        }\n\n        prev = temp;\n    }\n\n    return prev[3];\n}\n</code></pre>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * 4 * 3)</code></li> <li>Space Complexity: <code>O(4)</code></li> </ul>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/ninja-s-training_3621003</li> </ul>"},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#tags","title":"Tags","text":""},{"location":"DSA/DP/7%29%20Ninja%27s%20Training/#recursion-sum-dp-maximization","title":"recursion #sum #dp #maximization","text":""},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/","title":"8) Grid Unique Paths","text":""},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#description","title":"Description","text":"<ul> <li>Count all unique paths on m x n grid by going only down and right.</li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#1-memorization","title":"1) Memorization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    if (i == 0 &amp;&amp; j == 0) return 1;\n\n    if (i &lt; 0 || j &lt; 0) return 0;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = solve(i-1, j, dp);\n    int left = solve(i, j-1, dp);\n\n    return dp[i][j] = up + left;\n} \n\nint uniquePaths(int m, int n) {\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n, -1));\n\n    return solve(m-1, n-1, dp);\n}\n</code></pre>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)</code></li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#2-tabulation","title":"2) Tabulation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n, 0));\n    dp[0][0] = 1;\n\n    for (int i=0; i&lt;m; i++) {\n        for (int j=0; j&lt;n; j++) {\n            if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = dp[i-1][j];\n                if (j &gt; 0) left = dp[i][j-1];\n                dp[i][j] = up + left;\n            }\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n</code></pre>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    vector&lt;int&gt; prev_row(n);\n    prev_row[0] = 1;\n\n    for (int i=0; i&lt;m; i++) {\n        vector&lt;int&gt; row(n);\n        for (int j=0; j&lt;n; j++) {\n            if (i == 0 &amp;&amp; j == 0) row[j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = prev_row[j];\n                if (j &gt; 0) left = row[j-1];\n                row[j] = up + left;\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[n-1];\n}\n</code></pre>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#notes","title":"Notes","text":"<ul> <li>Answer is (m + n - 2) C (m - 1).</li> </ul> <p>![[Pasted image 20250323133732.png]]</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint uniquePaths(int m, int n) {\n    int N = m + n - 2;\n    int r = m - 1;\n    double res = 1;\n\n    for (int i=1; i&lt;=r; i++) {\n        res = (res * (N - r + i)) / i;\n    }\n\n    return int(res);\n}\n</code></pre>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#analysis_3","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/total-unique-paths_1081470</li> </ul>"},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#tags","title":"Tags","text":""},{"location":"DSA/DP/8%29%20Grid%20Unique%20Paths/#dp-recursion-count-grid","title":"dp #recursion #count #grid","text":""},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/","title":"9) Grid Unique Paths 2","text":""},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#description","title":"Description","text":"<ul> <li>Here there will be dead cells (-1).</li> </ul>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#solutions","title":"Solutions","text":""},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#1-memorization","title":"1) Memorization","text":"<pre><code>int mod = 1e9 + 7;\n\nint solve(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;dp, vector&lt;vector&lt;int&gt;&gt; &amp;mat) {\n    if (i == 0 &amp;&amp; j == 0) return 1;\n\n    if (i &lt; 0 || j &lt; 0) return 0;\n\n    if (mat[i][j] == -1) return 0;\n\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int up = solve(i-1, j, dp, mat);\n    int left = solve(i, j-1, dp, mat);\n\n    return dp[i][j] = (up + left) % mod;\n} \n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, -1));\n\n    return solve(n-1, m-1, dp, mat);\n}\n</code></pre>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(path length) + O(m * n) = O(m - 1 + n - 1) + O(m * n)</code></li> </ul>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#2-tabulation","title":"2) Tabulation","text":"<pre><code>int mod = 1e9 + 7;\n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (m, 0));\n    dp[0][0] = 1;\n\n    for (int i=0; i&lt;n; i++) {\n        for (int j=0; j&lt;m; j++) {\n            if (mat[i][j] == -1) dp[i][j] = 0;\n            else if(i == 0 &amp;&amp; j == 0) dp[i][j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = dp[i-1][j];\n                if (j &gt; 0) left = dp[i][j-1];\n                dp[i][j] = (up + left) % mod;\n            }\n        }\n    }\n\n    return dp[n-1][m-1];\n}\n</code></pre>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(m * n)</code></li> </ul>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#3-space-optimization","title":"3) Space Optimization","text":"<pre><code>int mod = 1e9 + 7;\n\nint mazeObstacles(int n, int m, vector&lt; vector&lt; int&gt; &gt; &amp;mat) {\n    vector&lt;int&gt; prev_row(n);\n    prev_row[0] = 1;\n\n    for (int i=0; i&lt;n; i++) {\n        vector&lt;int&gt; row(m);\n        for (int j=0; j&lt;m; j++) {\n            if (mat[i][j] == -1) row[j] = 0;\n            else if(i == 0 &amp;&amp; j == 0) row[j] = 1;\n            else {\n                int up = 0, left = 0;\n                if (i &gt; 0) up = prev_row[j];\n                if (j &gt; 0) left = row[j-1];\n                row[j] = (up + left) % mod;\n            }\n        }\n\n        prev_row = row;\n    }\n\n    return prev_row[m-1];\n}\n</code></pre>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#analysis_2","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(m * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.naukri.com/code360/problems/unique-paths-ii_977241</li> </ul>"},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#tags","title":"Tags","text":""},{"location":"DSA/DP/9%29%20Grid%20Unique%20Paths%202/#dp-recursion-count-grid","title":"dp #recursion #count #grid","text":""},{"location":"DSA/Recursion/1%29%20Print%20all%20subsequences/","title":"1) Print all subsequences","text":""},{"location":"DSA/Recursion/1%29%20Print%20all%20subsequences/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid subseq(int ind, vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;ds) {\n    if (ind == a.size()) {\n        for (auto num : ds) {\n            cout &lt;&lt; num &lt;&lt; \" \";\n        }\n\n        if (ds.size() == 0) {\n            cout &lt;&lt; \"{}\";\n        }\n\n        cout &lt;&lt; endl;\n        return;\n    };\n\n    // take\n    ds.push_back(a[ind]);\n    subseq(ind + 1, a, ds);\n    ds.pop_back();\n\n    // not-take\n    subseq(ind + 1, a, ds);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);   \n\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n\n    subseq(0, a, ds);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/1%29%20Print%20all%20subsequences/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code> <ul> <li>2^n for all subseq</li> <li>n for printing</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/1%29%20Print%20all%20subsequences/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/1%29%20Print%20all%20subsequences/#recursion-take-not-take-subsequence","title":"recursion #take-not-take #subsequence","text":""},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/","title":"10) Subset Sum 2","text":""},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#description","title":"Description","text":"<ul> <li>Return all possible subsets of an array. The array can contain duplicates.</li> </ul>"},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        ans.push_back(ds);\n\n        for (int i=ind; i&lt;nums.size(); i++) {\n            if (i &gt; ind &amp;&amp; nums[i] == nums[i-1]) continue;\n\n            ds.push_back(nums[i]);\n            recurse(i + 1, nums, ds, ans);\n            ds.pop_back();\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n\n        sort(nums.begin(), nums.end());\n\n        recurse(0, nums, ds, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code></li> <li>Space Complexity: <code>O(2^n * k)</code></li> </ul>"},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/subsets-ii</li> </ul>"},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/10%29%20Subset%20Sum%202/#recursion-sum-subset-sum-subset","title":"recursion #sum #subset-sum #subset","text":""},{"location":"DSA/Recursion/11%29%20Permutation/","title":"11) Permutation","text":""},{"location":"DSA/Recursion/11%29%20Permutation/#description","title":"Description","text":"<ul> <li>Return all the permutation of an array with distinct elements.</li> </ul>"},{"location":"DSA/Recursion/11%29%20Permutation/#solution-1-using-boolean-taken-array","title":"Solution 1 - Using boolean taken array","text":"<pre><code>class Solution {\npublic:\n    void recurse(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;ds, vector&lt;bool&gt; &amp;taken, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ds.size() == nums.size()) {\n            ans.push_back(ds);\n            return;\n        }\n\n        for (int i=0; i&lt;nums.size(); i++) {\n            if (!taken[i]) {\n                taken[i] = true;\n                ds.push_back(nums[i]);\n                recurse(nums, ds, taken, ans);\n                ds.pop_back();\n                taken[i] = false;        \n            }\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n        vector&lt;bool&gt; taken(n, 0);\n\n        recurse(nums, ds, taken, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/11%29%20Permutation/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n! * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/11%29%20Permutation/#solution-2-without-taken-array-using-swapping","title":"Solution 2 - Without taken array; using swapping","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ind == nums.size()) {\n            ans.push_back(nums);\n            return;\n        }\n\n        for (int i=ind; i&lt;nums.size(); i++) {\n            swap(nums[i], nums[ind]);\n            recurse(ind + 1, nums, ans);\n            swap(nums[i], nums[ind]);\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        recurse(0, nums, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/11%29%20Permutation/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n! * n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/11%29%20Permutation/#notes","title":"Notes","text":"<p>Approach 2:</p> <p>![[Pasted image 20250319125454.png]]</p>"},{"location":"DSA/Recursion/11%29%20Permutation/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/permutations/</li> </ul>"},{"location":"DSA/Recursion/11%29%20Permutation/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/11%29%20Permutation/#recursion-permutation","title":"recursion #permutation","text":""},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/","title":"12) N Queens Problem","text":""},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#description","title":"Description","text":"<ul> <li>For n sized chessboard, place n queens such that:<ul> <li>Each row has exactly 1 queen</li> <li>Each col has exactly 1 queen</li> <li>Queens should not attach each other</li> </ul> </li> </ul>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#solution-1","title":"Solution 1","text":"<pre><code>class Solution {\npublic:\n\n    bool isValid(int row, int col, int &amp;n, vector&lt;string&gt; &amp;board) {\n\n        // check left\n        for (int c=0; c&lt;col; c++) {\n            if (board[row][c] == 'Q') return false;\n        }\n\n        // check upper-diagonal\n        int r = row - 1, c = col - 1;\n        while (r &gt;= 0 &amp;&amp; c &gt;= 0) {\n            if (board[r][c] == 'Q') return false;\n            r--;\n            c--;\n        }\n\n        // check lower-diagonal\n        r = row + 1, c = col - 1;\n        while (r &lt; n &amp;&amp; c &gt;= 0) {\n            if (board[r][c] == 'Q') return false;\n            r++;\n            c--;\n        }\n\n        return true;\n    }\n\n    void recurse(int col, int &amp;n, vector&lt;string&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (col == n) {\n            ans.push_back(board);\n            return;\n        }\n\n        for (int row=0; row&lt;n; row++) {\n            if (isValid(row, col, n, board)) {\n                board[row][col] = 'Q';\n                recurse(col + 1, n, board, ans);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        string s(n, '.');\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board(n, s);\n\n        recurse(0, n, board, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n^2 * n!)</code> due to pruning n^n is reduced to n!</li> <li>Space Complexity: <code>O(n^2 + n!)</code></li> </ul>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#solution-2-optimizing-issafe-logic","title":"Solution 2 - Optimizing isSafe Logic","text":"<pre><code>class Solution {\npublic:\n\n    vector&lt;int&gt; leftRow, lowDiag, upDiag;\n\n    void recurse(int col, int &amp;n, vector&lt;string&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (col == n) {\n            ans.push_back(board);\n            return;\n        }\n\n        for (int row=0; row&lt;n; row++) {\n            if (!leftRow[row] &amp;&amp; !upDiag[(n - 1) + (col - row)] &amp;&amp; !lowDiag[row + col]) {\n                board[row][col] = 'Q';\n\n                leftRow[row] = true;\n                lowDiag[row + col] = true;\n                upDiag[(n - 1) + (col - row)] = true;\n\n                recurse(col + 1, n, board, ans);\n\n                board[row][col] = '.';\n\n                leftRow[row] = false;\n                lowDiag[row + col] = false;\n                upDiag[(n - 1) + (col - row)] = false;\n            }\n        }\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        string s(n, '.');\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board(n, s);\n\n        leftRow.resize(n, 0);\n        lowDiag.resize(2*n - 1, 0);\n        upDiag.resize(2*n - 1, 0);\n\n        recurse(0, n, board, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#analysis_1","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n * n!)</code></li> <li>Space Complexity: <code>O(n^2 + n!)</code></li> </ul>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#notes","title":"Notes","text":"<p>![[Pasted image 20250319132401.png]]</p> <p>For optimizing isSafe Logic ![[Pasted image 20250319134959.png]]</p>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/n-queens/</li> </ul>"},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/12%29%20N-Queens%20Problem/#recursion-n-queens","title":"recursion #n-queens","text":""},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/","title":"13) Sudoku Solver","text":""},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool isValid(char chr, int r, int c, vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i=0; i&lt;9; i++) {\n            // row\n            if (chr == board[r][i]) return false;\n\n            // col\n            if (chr == board[i][c]) return false;\n\n            // box\n            if (chr == board[3 * (r/3) + i/3][3 * (c/3) + i%3]) return false;\n        }\n\n        return true;\n    }\n\n    bool recurse(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int r=0; r&lt;board.size(); r++) {\n            for (int c=0; c&lt;board.size(); c++) {\n                if (board[r][c] == '.') {\n                    for (char chr = '1'; chr &lt;= '9'; chr++) {\n                        if (isValid(chr, r, c, board)) {\n                            board[r][c] = chr;\n\n                            if (recurse(board))\n                                return true;\n                            else\n                                board[r][c] = '.';\n                        }\n                    }\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        recurse(board);\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(9^81)</code> in worst case but much lower in practical scenarios due to pruning and constraints.</li> <li>Space Complexity: <code>O(81) = O(1)</code></li> </ul>"},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#notes","title":"Notes","text":"<p>![[Pasted image 20250319143838.png]]</p>"},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/sudoku-solver/</li> </ul>"},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/13%29%20Sudoku%20Solver/#recursion-sudoku","title":"recursion #sudoku","text":""},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/","title":"14) M Coloring Problem","text":""},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    bool isValid(int node, int color, vector&lt;vector&lt;int&gt;&gt; &amp;adj, vector&lt;int&gt; &amp;col) {\n        for (auto ngbr : adj[node]) {\n            if (col[ngbr] == color)\n                return false;\n        }\n\n        return true;\n    }\n\n    bool recurse(int node, int &amp;v, int &amp;m, vector&lt;vector&lt;int&gt;&gt; &amp;adj, vector&lt;int&gt; &amp;col) {\n        if (node == v)\n            return true;\n\n        for (int i=1; i&lt;=m; i++) {\n            if (isValid(node, i, adj, col)) {\n                col[node] = i;\n                if (recurse(node + 1, v, m, adj, col)) return true;\n                col[node] = 0;\n            }\n        }\n\n        return false;\n    }\n\n    bool graphColoring(int v, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges, int m) {\n        vector&lt;vector&lt;int&gt;&gt; adj(v);\n\n        for (auto &amp;edge : edges) {\n            adj[edge.first].push_back(edge.second);\n            adj[edge.second].push_back(edge.first);\n        }\n\n        vector&lt;int&gt; col(v, 0);\n\n        return recurse(0, v, m, adj, col);\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(N^M)</code> N = no of nodes, M = colors</li> <li>Space Complexity: <code>O(N)</code></li> </ul>"},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1</li> </ul>"},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/14%29%20M-Coloring%20Problem/#recursion-m-coloring","title":"recursion #m-coloring","text":""},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/","title":"15) Palindrome Partitioning","text":""},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#description","title":"Description","text":"<ul> <li>Return all possible partitions of strings which are all palindromes.</li> </ul>"},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool check_palindrome(int i, int j, string &amp;s) {\n        while (i &lt; j) {\n            if (s[i] != s[j])\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    void recurse(int ind, string &amp;s, vector&lt;string&gt; &amp;ds, vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n        if (ind == s.size()) {\n            ans.push_back(ds);\n            return;\n        }\n\n        for (int i=ind; i&lt;s.size(); i++) {\n            if (check_palindrome(ind, i, s)) {\n                ds.push_back(s.substr(ind, i - ind + 1));\n                recurse(i + 1, s, ds, ans);\n                ds.pop_back();\n            }\n        }\n    } \n\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; ds;\n\n        recurse(0, s, ds, ans);\n\n        return ans;      \n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code></li> <li>Space Complexity: <code>O(2^n * n)</code></li> </ul>"},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#notes","title":"Notes","text":"<p>![[Pasted image 20250319193125.png]]</p>"},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/palindrome-partitioning/</li> </ul>"},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/15%29%20Palindrome%20Partitioning/#recursion-palindrome","title":"recursion #palindrome","text":""},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/","title":"16) Rat in a Maze","text":""},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#description","title":"Description","text":"<ul> <li>Find all possible paths to go from (0, 0) to (n-1, n-1). 0 means water and 1 means land.</li> </ul>"},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    vector&lt;int&gt; di = {1, 0, 0, -1};\n    vector&lt;int&gt; dj = {0, -1, 1, 0};\n\n    void recurse(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;mat, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, string &amp;path, vector&lt;string&gt; &amp;ans) {\n\n        if (i == mat.size() - 1 &amp;&amp; j == mat.size() - 1) {\n            ans.push_back(path);\n            return;\n        }\n\n        string dir = \"DLRU\";\n\n        for (int ind=0; ind&lt;4; ind++) {\n            int x = i + di[ind];\n            int y = j + dj[ind];\n\n            if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; mat.size() &amp;&amp; y &lt; mat.size() &amp;&amp; !vis[x][y] &amp;&amp; mat[x][y]) {\n                vis[i][j] = true;\n                path.push_back(dir[ind]);\n                recurse(x, y, mat, vis, path, ans);\n                path.pop_back();\n                vis[i][j] = false;\n            }\n        }\n    }\n\n    vector&lt;string&gt; findPath(vector&lt;vector&lt;int&gt;&gt; &amp;mat) {\n        vector&lt;string&gt; ans;\n        string path;\n        int n = mat.size();\n        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(n, 0));\n\n        if (mat[0][0]) recurse(0, 0, mat, vis, path, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(4^(n*m))</code></li> <li>Space Complexity: <code>O(n*m)</code></li> </ul>"},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#notes","title":"Notes","text":"<p>![[Pasted image 20250319195919.png]]</p>"},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/rat-in-a-maze-problem/1</li> </ul>"},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/16%29%20Rat%20in%20a%20Maze/#recursion-land-water-grid","title":"recursion #land-water #grid","text":""},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/","title":"17) K th Permutation","text":""},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#solution","title":"Solution","text":"<ul> <li>Do recursion and find the kth permutation. </li> <li>But it would be a brute force.</li> <li>Here is the optimal solution.</li> </ul> <pre><code>class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector&lt;int&gt; v(n);\n        string ans = \"\";\n\n        for (int i=0; i&lt;n; i++) v[i] = i + 1;\n\n        int fact = 1;\n        for (int i=1; i&lt;n; i++) fact *= i;\n        k--;\n\n        while (n != 1) {\n            int ind = k / fact;\n            ans += v[ind] + '0';\n            v.erase(v.begin() + ind);\n            k = k % fact;\n            n--;\n            fact /= n;\n        }\n\n        ans += v[0] + '0';\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(n*n) = O(n^2)</code><ul> <li>1st n for all the numbers in a permutation</li> <li>2nd n for erasing that number from the left array</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#notes","title":"Notes","text":"<p>![[Pasted image 20250319224709.png]]</p>"},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/permutation-sequence/</li> </ul>"},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/17%29%20K-th%20Permutation/#recursion","title":"recursion","text":""},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/","title":"18) Count no. of Inversions","text":""},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#description","title":"Description","text":"<ul> <li>count pairs (i, j) where i &lt; j and a[i] &gt; a[j]</li> </ul>"},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#solution-merge-sort","title":"Solution (merge sort)","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint merge(vector&lt;int&gt; &amp;a, int low, int mid, int high) {\n    int cnt = 0;\n    vector&lt;int&gt; temp;\n\n    int left = low;\n    int right = mid + 1;\n\n    while (left &lt;= mid &amp;&amp; right &lt;= high) {\n        if (a[left] &lt;= a[right]) {\n            temp.push_back(a[left]);\n            left++;\n        } \n        else {\n            temp.push_back(a[right]);\n            cnt += (mid - left + 1);\n            right++;\n        }\n    }\n\n    while (left &lt;= mid) {\n        temp.push_back(a[left]);\n        left++;\n    }\n\n    while (right &lt;= high) {\n        temp.push_back(a[right]);\n        right++;\n    }\n\n    for (int i=low; i&lt;=high; i++) {\n        a[i] = temp[i - low];\n    }\n\n    return cnt;\n}\n\nint mergeSort(vector&lt;int&gt; &amp;a, int low, int high) {\n    int cnt = 0;\n\n    // base-condition\n    if (low &gt;= high) return cnt;\n\n    int mid = (low + high) / 2;\n\n    // left\n    cnt += mergeSort(a, low, mid);\n    // right\n    cnt += mergeSort(a, mid + 1, high);\n\n    // merge\n    cnt += merge(a, low, mid, high);\n\n    return cnt;\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    cout &lt;&lt; mergeSort(a, 0, n - 1);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#resources","title":"Resources","text":"<ul> <li>Problem Link: </li> </ul>"},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/18%29%20Count%20no.%20of%20Inversions/#recursion-merge-sort-count-inversions","title":"recursion #merge-sort #count #inversions","text":""},{"location":"DSA/Recursion/2%29%20Print%20all%20subsequence%20having%20sum%20K/","title":"2) Print all subsequence having sum K","text":""},{"location":"DSA/Recursion/2%29%20Print%20all%20subsequence%20having%20sum%20K/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid sum_K(int ind, vector&lt;int&gt; &amp;ds, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        if (sum == k) {\n            for (auto num : ds) {\n                cout &lt;&lt; num &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n        }\n        return;\n    }\n\n    // take\n    ds.push_back(a[ind]);\n    sum += a[ind];\n    sum_K(ind + 1, ds, a, sum, k);\n    ds.pop_back();\n    sum -= a[ind];\n\n    // not-take\n    sum_K(ind + 1, ds, a, sum, k);\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n    int sum = 0;\n    sum_K(0, ds, a, sum, k);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/2%29%20Print%20all%20subsequence%20having%20sum%20K/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n * n)</code><ul> <li>2^n for all subseq</li> <li>n for printing</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/2%29%20Print%20all%20subsequence%20having%20sum%20K/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/2%29%20Print%20all%20subsequence%20having%20sum%20K/#recursion-take-not-take-subsequence-sum-k","title":"recursion #take-not-take #subsequence #sum-k","text":""},{"location":"DSA/Recursion/3%29%20Print%20anyone%20subsequence%20with%20sum%20K/","title":"3) Print anyone subsequence with sum K","text":""},{"location":"DSA/Recursion/3%29%20Print%20anyone%20subsequence%20with%20sum%20K/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nbool sum_K(int ind, vector&lt;int&gt; &amp;ds, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        // condition - satisfied\n        if (sum == k) {\n            for (auto num : ds) {\n                cout &lt;&lt; num &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n            return true;\n        }\n\n        // condition - not satisfied\n        return false;\n    }\n\n    // take\n    ds.push_back(a[ind]);\n    sum += a[ind];\n\n    if (sum_K(ind + 1, ds, a, sum, k) == true) {\n        return true;\n    }\n\n    ds.pop_back();\n    sum -= a[ind];\n\n    // not-take\n    if (sum_K(ind + 1, ds, a, sum, k) == true) {\n        return true;\n    }\n\n    return false;\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    vector&lt;int&gt; ds;\n    int sum = 0;\n\n    if (!sum_K(0, ds, a, sum, k)) {\n\u00a0 \u00a0 \u00a0 \u00a0 cout &lt;&lt; \"No subsequence\";\n\u00a0 \u00a0 }\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/3%29%20Print%20anyone%20subsequence%20with%20sum%20K/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/3%29%20Print%20anyone%20subsequence%20with%20sum%20K/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/3%29%20Print%20anyone%20subsequence%20with%20sum%20K/#recursion-sum-k-subsequence-take-not-take-only-one","title":"recursion #sum-k #subsequence #take-not-take #only-one","text":""},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/","title":"4) Count all subsequences with sum K","text":""},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint sum_K(int ind, vector&lt;int&gt; &amp;a, int &amp;sum, int k) {\n    if (ind == a.size()) {\n        // condition - satisfied\n        if (sum == k) {\n            return 1;\n        }\n\n        // condition - not satisfied\n        return 0;\n    }\n\n    // take\n    sum += a[ind];\n\n    int l = sum_K(ind + 1, a, sum, k);\n\n    sum -= a[ind];\n\n    // not-take\n    int r = sum_K(ind + 1, a, sum, k);\n\n    return l + r;\n}\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    int sum = 0;\n\n    cout &lt;&lt; sum_K(0, a, sum, k);\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/#notes","title":"Notes","text":"<p>![[Pasted image 20250315195148.png]]</p>"},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/4%29%20Count%20all%20subsequences%20with%20sum%20K/#recursion-subsequence-sum-k-take-not-take-count","title":"recursion #subsequence #sum-k #take-not-take #count","text":""},{"location":"DSA/Recursion/5%29%20Merge%20Sort/","title":"5) Merge Sort","text":""},{"location":"DSA/Recursion/5%29%20Merge%20Sort/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nvoid merge(vector&lt;int&gt; &amp;a, int low, int mid, int high) {\n    vector&lt;int&gt; temp;\n\n    int left = low;\n    int right = mid + 1;\n\n    while (left &lt;= mid &amp;&amp; right &lt;= high) {\n        if (a[left] &lt;= a[right]) {\n            temp.push_back(a[left]);\n            left++;\n        } \n        else {\n            temp.push_back(a[right]);\n            right++;\n        }\n    }\n\n    while (left &lt;= mid) {\n        temp.push_back(a[left]);\n        left++;\n    }\n\n    while (right &lt;= high) {\n        temp.push_back(a[right]);\n        right++;\n    }\n\n    for (int i=low; i&lt;=high; i++) {\n        a[i] = temp[i - low];\n    }\n}\n\nvoid mergeSort(vector&lt;int&gt; &amp;a, int low, int high) {\n\n    // base-condition\n    if (low &gt;= high) return;\n\n    int mid = (low + high) / 2;\n\n    // left\n    mergeSort(a, low, mid);\n    // right\n    mergeSort(a, mid + 1, high);\n\n    // merge\n    merge(a, low, mid, high);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    mergeSort(a, 0, n - 1);\n\n    for (int i=0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/5%29%20Merge%20Sort/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code><ul> <li>n for merge at each level</li> <li>logn for the levels of tree</li> </ul> </li> <li>Space Complexity: <code>O(n)</code></li> </ul>"},{"location":"DSA/Recursion/5%29%20Merge%20Sort/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/5%29%20Merge%20Sort/#recursion-merge-sort-sorting-divide-and-conquer-algorithm","title":"recursion #merge-sort #sorting #divide-and-conquer #algorithm","text":""},{"location":"DSA/Recursion/6%29%20Quick%20Sort/","title":"6) Quick Sort","text":""},{"location":"DSA/Recursion/6%29%20Quick%20Sort/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\n\n#define ll long long\n#define pb push_back\n\nint partition(vector&lt;int&gt; &amp;a, int low, int high) {\n    int pivot = a[low];\n\n    int i = low, j = high;\n\n    while (i &lt; j) {\n        while (a[i] &lt;= pivot &amp;&amp; i &lt;= high - 1) {\n            i++;\n        }\n\n        while (a[j] &gt; pivot &amp;&amp; j &gt;= low + 1) {\n            j--;\n        }\n\n        if (i &lt; j) {\n            swap(a[i], a[j]);\n        }\n    }\n\n    swap(a[low], a[j]);\n\n    return j;\n}\n\nvoid quickSort(vector&lt;int&gt; &amp;a, int low, int high) {\n    if (low &gt;= high) return;\n\n    int pivot = partition(a, low, high);\n    // left\n    quickSort(a, low, pivot - 1);\n\n    // right\n    quickSort(a, pivot + 1, high);\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n\n    quickSort(a, 0, n - 1);\n\n    for (int i=0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"DSA/Recursion/6%29%20Quick%20Sort/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(nlogn)</code></li> <li>Space Complexity: <code>O(1)</code></li> </ul>"},{"location":"DSA/Recursion/6%29%20Quick%20Sort/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/6%29%20Quick%20Sort/#recursion-quick-sort-sorting-algorithm-divide-and-conquer","title":"recursion #quick-sort #sorting #algorithm #divide-and-conquer","text":""},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/","title":"7) Combination Sum 1","text":""},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#description","title":"Description","text":"<ul> <li>From a list of distinct numbers, find all unique combinations which sums to target. Same element can be taken more than once.</li> </ul>"},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    void recurse(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if (ind == arr.size()) {\n            if (target == 0) ans.push_back(ds);\n            return;\n        }\n\n        // take\n        if (arr[ind] &lt;= target) {\n            ds.push_back(arr[ind]);\n            recurse(ind, target - arr[ind], arr, ds, ans);\n            ds.pop_back();\n        }\n\n        // not-take\n        recurse(ind + 1, target, arr, ds, ans);\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n\n        recurse(0, target, candidates, ds, ans);\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^t * k)</code></li> <li>Space Complexity: <code>O(k * x)</code></li> </ul>"},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/combination-sum/</li> </ul>"},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/7%29%20Combination%20Sum%201/#recursion-take-not-take-sum-combination-sum","title":"recursion #take-not-take #sum #combination-sum","text":""},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/","title":"8) Combination Sum 2","text":""},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#description","title":"Description","text":"<ul> <li>From a list of numbers, find all unique combinations which sums to target. Each number can be used only once in a combination.</li> </ul>"},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#solution","title":"Solution","text":"<pre><code>class Solution {\n    public:\n        void recurse(int ind, int target, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ds, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n            if (target == 0) {\n                ans.push_back(ds);\n                return;\n            }\n\n            for (int i=ind; i&lt;arr.size(); i++) {\n                if (i &gt; ind &amp;&amp; arr[i] == arr[i-1]) continue;\n\n                if (arr[i] &gt; target) break;\n\n                ds.push_back(arr[i]);\n                recurse(i + 1, target - arr[i], arr, ds, ans);\n                ds.pop_back();\n            }\n        }\n\n        vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n            sort(candidates.begin(), candidates.end());\n            vector&lt;int&gt; ds;\n            vector&lt;vector&lt;int&gt;&gt; ans;\n\n            recurse(0, target, candidates, ds, ans);\n\n            return ans;\n        }\n    };\n</code></pre>"},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^t * k)</code></li> <li>Space Complexity: <code>O(k * x)</code></li> </ul>"},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#notes","title":"Notes","text":"<ul> <li>![[Pasted image 20250318202820.png]]</li> </ul>"},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://leetcode.com/problems/combination-sum-ii/</li> </ul>"},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/8%29%20Combination%20Sum%202/#recursion-sum-combination-sum","title":"recursion #sum #combination-sum","text":""},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/","title":"9) Subset Sum 1","text":""},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#description","title":"Description","text":"<ul> <li>Return the sums of all the subsets possible.</li> </ul>"},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#solution","title":"Solution","text":"<pre><code>class Solution {\n  public:\n    void recurse(int ind, int &amp;sum, vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;ans) {\n        if (ind == arr.size()) {\n            ans.push_back(sum);\n            return;\n        }\n\n        // take\n        sum += arr[ind];\n        recurse(ind + 1, sum, arr, ans);\n        sum -= arr[ind];\n\n        // not-take\n        recurse(ind + 1, sum, arr, ans);\n    }\n\n    vector&lt;int&gt; subsetSums(vector&lt;int&gt;&amp; arr) {\n        vector&lt;int&gt; ans;\n        int sum = 0;\n\n        recurse(0, sum, arr, ans);\n\n        sort(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n</code></pre>"},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#analysis","title":"Analysis","text":"<ul> <li>Time Complexity: <code>O(2^n)</code></li> <li>Space Complexity: <code>O(2^n)</code></li> </ul>"},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#resources","title":"Resources","text":"<ul> <li>Problem Link: https://www.geeksforgeeks.org/problems/subset-sums2234/1</li> </ul>"},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#tags","title":"Tags","text":""},{"location":"DSA/Recursion/9%29%20Subset%20Sum%201/#recursion-subset-sum-subset-sum-take-not-take","title":"recursion #subset #sum #subset-sum #take-not-take","text":""}]}